// Copyright 2024 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package android

import (
	"github.com/google/blueprint"
	"github.com/google/blueprint/proptools"
)

var (
	removeComments = pctx.AndroidStaticRule("remove_comments",
		blueprint.RuleParams{
			Command: "grep -v '#' $in > $out",
		},
	)
	androidInfoTxtToProp = pctx.AndroidStaticRule("android_info_txt_to_prop",
		blueprint.RuleParams{
			Command: "grep 'require version-' $in | sed -e 's/require version-/ro.build.expect./g' > $out",
		},
	)
)

type AndroidInfoProperties struct {
	// Name of output file. Defaults to module name
	Stem *string

	// Paths of board-info.txt files.
	Board_info_files []string `android:"path"`

	// Name of bootloader board. If board_info_files is empty, `board={bootloader_board_name}` will
	// be printed to output. Ignored if board_info_files is not empty.
	Bootloader_board_name *string
}

type androidInfoModule struct {
	ModuleBase

	properties AndroidInfoProperties
}

type AndroidInfo struct {
	// Path to the android info prop file which is used to generate the vendor/build.prop
	AndroidInfoProp Path
	// Path to the android info txt file, which is generated by merging the board info txt files
	// and removing the comments
	AndroidInfoTxt Path
	// Path to the merged board info txt file, with comments
	BoardInfoTxt Path
}

var AndroidInfoProvider = blueprint.NewProvider[AndroidInfo]()

func (p *androidInfoModule) GenerateAndroidBuildActions(ctx ModuleContext) {
	if len(p.properties.Board_info_files) > 0 && p.properties.Bootloader_board_name != nil {
		ctx.ModuleErrorf("Either Board_info_files or Bootloader_board_name should be set. Please remove one of them\n")
		return
	}
	androidInfoTxtName := proptools.StringDefault(p.properties.Stem, ctx.ModuleName()+".txt")
	androidInfoTxt := PathForModuleOut(ctx, androidInfoTxtName)
	androidInfoProp := androidInfoTxt.ReplaceExtension(ctx, "prop")
	mergedBoardInfoTxt := PathForModuleOut(ctx, "board-info.txt")

	androidInfo := AndroidInfo{
		AndroidInfoProp: androidInfoProp,
		AndroidInfoTxt:  androidInfoTxt,
	}

	if boardInfoFiles := PathsForModuleSrc(ctx, p.properties.Board_info_files); len(boardInfoFiles) > 0 {
		ctx.Build(pctx, BuildParams{
			Rule:   Cat,
			Inputs: boardInfoFiles,
			Output: mergedBoardInfoTxt,
		})
		ctx.Build(pctx, BuildParams{
			Rule:   removeComments,
			Input:  mergedBoardInfoTxt,
			Output: androidInfoTxt,
		})
		androidInfo.BoardInfoTxt = mergedBoardInfoTxt
	} else if bootloaderBoardName := proptools.String(p.properties.Bootloader_board_name); bootloaderBoardName != "" {
		WriteFileRule(ctx, androidInfoTxt, "board="+bootloaderBoardName)
	} else {
		WriteFileRule(ctx, androidInfoTxt, "")
	}

	// Create android_info.prop
	ctx.Build(pctx, BuildParams{
		Rule:   androidInfoTxtToProp,
		Input:  androidInfoTxt,
		Output: androidInfoProp,
	})

	SetProvider(ctx, AndroidInfoProvider, androidInfo)

	ctx.SetOutputFiles(Paths{androidInfoProp}, "")
	ctx.SetOutputFiles(Paths{androidInfoTxt}, ".txt")
}

// android_info module generate a file named android-info.txt that contains various information
// about the device we're building for.  This file is typically packaged up with everything else.
func AndroidInfoFactory() Module {
	module := &androidInfoModule{}
	module.AddProperties(&module.properties)
	InitAndroidArchModule(module, DeviceSupported, MultilibCommon)
	return module
}
