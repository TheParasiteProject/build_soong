// Copyright (C) 2024 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package filesystem

import (
	"cmp"
	"fmt"
	"path/filepath"
	"regexp"
	"slices"
	"sort"
	"strings"
	"sync/atomic"

	"android/soong/android"
	"android/soong/etc"
	"android/soong/java"

	"github.com/google/blueprint"
	"github.com/google/blueprint/proptools"
)

type PartitionNameProperties struct {
	// Name of the super partition filesystem module
	Super_partition_name *string
	// Name of the boot partition filesystem module
	Boot_partition_name *string
	// Name of the boot 16k partition filesystem module
	Boot_16k_partition_name *string
	// Name of the vendor boot partition filesystem module
	Vendor_boot_partition_name *string
	// Name of the vendor boot debug partition filesystem module
	Vendor_boot_debug_partition_name *string
	// Name of the vendor boot test harness partition filesystem module
	Vendor_boot_test_harness_partition_name *string
	// Name of the vendor kernel boot partition filesystem module
	Vendor_kernel_boot_partition_name *string
	// Name of the init boot partition filesystem module
	Init_boot_partition_name *string
	// Name of the system partition filesystem module
	System_partition_name *string
	// Name of the system_ext partition filesystem module
	System_ext_partition_name *string
	// Name of the product partition filesystem module
	Product_partition_name *string
	// Name of the vendor partition filesystem module
	Vendor_partition_name *string
	// Name of the odm partition filesystem module
	Odm_partition_name *string
	// Name of the recovery partition filesystem module
	Recovery_partition_name *string
	// The vbmeta partition and its "chained" partitions
	Vbmeta_partitions []string
	// Name of the userdata partition filesystem module
	Userdata_partition_name *string
	// Name of the system_dlkm partition filesystem module
	System_dlkm_partition_name *string
	// Name of the vendor_dlkm partition filesystem module
	Vendor_dlkm_partition_name *string
	// Name of the odm_dlkm partition filesystem module
	Odm_dlkm_partition_name *string
	// Name of the ramdisk partition module
	Ramdisk_partition_name *string
	// Name of the vendor kernel ramdisk partition filesystem module
	Vendor_kernel_ramdisk_partition_name *string
}

type DeviceProperties struct {
	// Prebuilt bootloader module that would be copied to PRODUCT_OUT
	Bootloader *string
	// Name of the android_info module that provides the board specific info.
	Android_info *string
	// If this is the "main" android_device target for the build, i.e. the one that gets built
	// when running a plain `m` command. Currently, this is the autogenerated android_device module
	// in soong-only builds, but in the future when we check in android_device modules, the main
	// one will be determined based on the lunch product. TODO: Figure out how to make this
	// blueprint:"mutated" and still set it from filesystem_creator
	Main_device *bool

	Ab_ota_updater            *bool
	Ab_ota_partitions         []string
	Ab_ota_keys               []string
	Ab_ota_postinstall_config []string

	Ramdisk_node_list      *string `android:"path"`
	Releasetools_extension *string `android:"path"`
	FastbootInfo           *string `android:"path"`

	Partial_ota_update_partitions []string
	Flash_block_size              *string
	Bootloader_in_update_package  *bool

	// The kernel version in the build. Will be verified against the actual kernel.
	// If not provided, will attempt to extract it from the loose kernel or the kernel inside
	// the boot image. The version is later used to decide whether or not to enable uffd_gc
	// when dexpreopting apps. So setting this doesn't really do anything except enforce that the
	// actual kernel version is as specified here.
	Kernel_version *string

	// Precompiled sepolicy only with system + system_ext + product. Used for SELinux tests.
	Precompiled_sepolicy_without_vendor *string `android:"path"`

	// Name of the DTBO partitions
	Dtbo_image     *string
	Dtbo_image_16k *string

	// Name of the radio partition
	Radio_partition_name *string

	Pvmfw PvmfwProperties

	Ramdisk_16k *string

	Vendor_blobs_license *string `android:"path"`

	// For saving those partition filesystems being created which are for gathering filesystem
	// infos but not going to create images for the device.
	InfoPartitionProps PartitionNameProperties
}

type PvmfwProperties struct {
	Image          *string `android:"path"`
	Binary         *string `android:"path"`
	Avbkey         *string `android:"path"`
	Partition_size *int64
}

type androidDevice struct {
	android.ModuleBase

	partitionProps PartitionNameProperties

	deviceProps DeviceProperties

	allImagesZip android.Path

	proguardZips                java.ProguardZips
	jacocoZip                   android.Path
	kernelConfig                android.Path
	kernelVersion               android.Path
	miscInfo                    android.Path
	rootDirForFsConfig          string
	rootDirForFsConfigTimestamp android.Path
	apkCertsInfo                android.Path
	targetFilesZip              android.Path
	updatePackage               android.Path
	otaFilesZip                 android.Path
	otaMetadata                 android.Path
	partialOtaFilesZip          android.Path
	androidInfoTxt              android.Path
	boardInfoTxt                android.Path

	symbolsZipFile     android.ModuleOutPath
	symbolsMappingFile android.ModuleOutPath

	withLicenseFile     android.Path
	withLicenseDistName string

	fastbootInfoFile android.Path
}

func AndroidDeviceFactory() android.Module {
	module := &androidDevice{}
	module.AddProperties(&module.partitionProps, &module.deviceProps)
	android.InitAndroidMultiTargetsArchModule(module, android.DeviceSupported, android.MultilibFirst)
	return module
}

var numMainAndroidDevicesOnceKey android.OnceKey = android.NewOnceKey("num_auto_generated_anroid_devices")

type partitionDepTagType struct {
	blueprint.BaseDependencyTag
}

type superPartitionDepTagType struct {
	blueprint.BaseDependencyTag
}
type targetFilesMetadataDepTagType struct {
	blueprint.BaseDependencyTag
}
type fileContextsDepTagType struct {
	blueprint.BaseDependencyTag
}
type bootloaderDepTagType struct {
	blueprint.BaseDependencyTag
}
type dtboDepTagType struct {
	blueprint.BaseDependencyTag
}
type radioDepTagType struct {
	blueprint.BaseDependencyTag
}
type ramdisk16kDepTagType struct {
	blueprint.BaseDependencyTag
}
type androidInfoDepTagType struct {
	blueprint.BaseDependencyTag
}

var superPartitionDepTag superPartitionDepTagType
var filesystemDepTag partitionDepTagType
var targetFilesMetadataDepTag targetFilesMetadataDepTagType
var fileContextsDepTag fileContextsDepTagType
var bootloaderDepTag bootloaderDepTagType
var dtboDepTag dtboDepTagType
var radioDepTag dtboDepTagType
var ramdisk16kDepTag ramdisk16kDepTagType
var androidInfoDepTag androidInfoDepTagType

func (a *androidDevice) DepsMutator(ctx android.BottomUpMutatorContext) {
	addDependencyIfDefined := func(dep *string) {
		if dep != nil {
			ctx.AddDependency(ctx.Module(), filesystemDepTag, proptools.String(dep))
		}
	}

	if a.partitionProps.Super_partition_name != nil {
		ctx.AddDependency(ctx.Module(), superPartitionDepTag, *a.partitionProps.Super_partition_name)
	}
	if a.deviceProps.InfoPartitionProps.Super_partition_name != nil {
		ctx.AddDependency(ctx.Module(), superPartitionDepTag, *a.deviceProps.InfoPartitionProps.Super_partition_name)
	}

	addDependencyIfDefined(a.partitionProps.Boot_partition_name)
	addDependencyIfDefined(a.partitionProps.Boot_16k_partition_name)
	addDependencyIfDefined(a.partitionProps.Init_boot_partition_name)
	addDependencyIfDefined(a.partitionProps.Vendor_boot_partition_name)
	addDependencyIfDefined(a.partitionProps.Vendor_boot_debug_partition_name)
	addDependencyIfDefined(a.partitionProps.Vendor_boot_test_harness_partition_name)
	addDependencyIfDefined(a.partitionProps.Vendor_kernel_boot_partition_name)
	addDependencyIfDefined(a.partitionProps.System_partition_name)
	addDependencyIfDefined(a.partitionProps.System_ext_partition_name)
	addDependencyIfDefined(a.partitionProps.Product_partition_name)
	addDependencyIfDefined(a.partitionProps.Vendor_partition_name)
	addDependencyIfDefined(a.partitionProps.Odm_partition_name)
	addDependencyIfDefined(a.partitionProps.Userdata_partition_name)
	addDependencyIfDefined(a.partitionProps.System_dlkm_partition_name)
	addDependencyIfDefined(a.partitionProps.Vendor_dlkm_partition_name)
	addDependencyIfDefined(a.partitionProps.Odm_dlkm_partition_name)
	addDependencyIfDefined(a.partitionProps.Recovery_partition_name)
	addDependencyIfDefined(a.partitionProps.Ramdisk_partition_name)
	addDependencyIfDefined(a.partitionProps.Vendor_kernel_ramdisk_partition_name)
	for _, vbmetaPartition := range a.partitionProps.Vbmeta_partitions {
		ctx.AddDependency(ctx.Module(), filesystemDepTag, vbmetaPartition)
	}
	a.addDepsForTargetFilesMetadata(ctx)
	if a.deviceProps.Bootloader != nil {
		ctx.AddDependency(ctx.Module(), bootloaderDepTag, *a.deviceProps.Bootloader)
	}
	if a.deviceProps.Dtbo_image != nil {
		ctx.AddDependency(ctx.Module(), dtboDepTag, *a.deviceProps.Dtbo_image)
	}
	if a.deviceProps.Dtbo_image_16k != nil {
		ctx.AddDependency(ctx.Module(), dtboDepTag, *a.deviceProps.Dtbo_image_16k)
	}
	if a.deviceProps.Radio_partition_name != nil {
		ctx.AddDependency(ctx.Module(), radioDepTag, *a.deviceProps.Radio_partition_name)
	}
	if a.deviceProps.Ramdisk_16k != nil {
		ctx.AddDependency(ctx.Module(), ramdisk16kDepTag, *a.deviceProps.Ramdisk_16k)
	}
	if a.deviceProps.Android_info != nil {
		ctx.AddDependency(ctx.Module(), androidInfoDepTag, *a.deviceProps.Android_info)
	}
	// Add system-build.prop even system partition is not building.
	ctx.AddDependency(ctx.Module(), filesystemDepTag, "system-build.prop")

	// For collecting install module information for products not building system.img or system_ext.img.
	addDependencyIfDefined(a.deviceProps.InfoPartitionProps.System_partition_name)
	addDependencyIfDefined(a.deviceProps.InfoPartitionProps.System_ext_partition_name)

	a.hostInitVerifierCheckDepsMutator(ctx)
}

func (a *androidDevice) addDepsForTargetFilesMetadata(ctx android.BottomUpMutatorContext) {
	ctx.AddFarVariationDependencies(ctx.Config().BuildOSTarget.Variations(), targetFilesMetadataDepTag, "liblz4") // host variant
	ctx.AddFarVariationDependencies(ctx.Config().AndroidCommonTarget.Variations(), fileContextsDepTag, "file_contexts_bin_gen")
}

func (a *androidDevice) UseGenericConfig() bool {
	return false
}

func (a *androidDevice) getAndroidInfoProvider(ctx android.ModuleContext) {
	if proptools.String(a.deviceProps.Android_info) != "" {
		mod := ctx.GetDirectDepProxyWithTag(*a.deviceProps.Android_info, androidInfoDepTag)
		if androidInfo, ok := android.OtherModuleProvider(ctx, mod, android.AndroidInfoProvider); ok {
			a.androidInfoTxt = androidInfo.AndroidInfoTxt
			a.boardInfoTxt = androidInfo.BoardInfoTxt
		} else {
			ctx.PropertyErrorf("Android_info", "Must be the android_info module type")
		}
	}
}

func (a *androidDevice) GenerateAndroidBuildActions(ctx android.ModuleContext) {
	if proptools.Bool(a.deviceProps.Main_device) {
		numMainAndroidDevices := ctx.Config().Once(numMainAndroidDevicesOnceKey, func() interface{} {
			return &atomic.Int32{}
		}).(*atomic.Int32)
		total := numMainAndroidDevices.Add(1)
		if total > 1 {
			// There should only be 1 main android_device module. That one will be
			// made the default thing to build in soong-only builds.
			ctx.ModuleErrorf("There cannot be more than 1 main android_device module")
		}
	}
	if a.partitionProps.Init_boot_partition_name != nil && a.partitionProps.Ramdisk_partition_name != nil {
		ctx.ModuleErrorf("Init_boot and Ramdisk cannot both be non-empty.")
	}

	// Normal allInstalledModules which only include modules in those partitions which will be create images for this product.
	allInstalledModules := a.allInstalledModules(ctx, false)

	a.getAndroidInfoProvider(ctx)
	a.apkCertsInfo = a.buildApkCertsInfo(ctx)
	a.kernelVersion, a.kernelConfig = a.extractKernelVersionAndConfigs(ctx)
	a.miscInfo = a.addMiscInfo(ctx)
	// Use the allInstalledModules which included modules which is installed under system or sysem_ext.
	// Because target file's apexkeys.txt collect those apex under system or system_ext even they don't build these 2 images.
	a.buildTargetFilesZip(ctx, a.allInstalledModules(ctx, true))
	a.proguardZips = java.BuildProguardZips(ctx, allInstalledModules)
	a.buildSymbolsZip(ctx, allInstalledModules)
	a.buildUpdatePackage(ctx)
	a.buildWithLicenseZip(ctx)

	if ctx.Config().IsEnvTrue("EMMA_INSTRUMENT") {
		jacocoZip := android.PathForModuleOut(ctx, "jacoco-report-classes-all.jar")
		java.BuildJacocoZipWithPotentialDeviceTests(ctx, allInstalledModules, jacocoZip)
		a.jacocoZip = jacocoZip
	}

	var deps []android.Path
	if proptools.String(a.partitionProps.Super_partition_name) != "" {
		superImage := ctx.GetDirectDepProxyWithTag(*a.partitionProps.Super_partition_name, superPartitionDepTag)
		if info, ok := android.OtherModuleProvider(ctx, superImage, SuperImageProvider); ok {
			assertUnset := func(prop *string, propName string) {
				if prop != nil && *prop != "" {
					ctx.PropertyErrorf(propName, "Cannot be set because it's already part of the super image")
				}
			}
			for _, subPartitionType := range android.SortedKeys(info.SubImageInfo) {
				switch subPartitionType {
				case "system":
					assertUnset(a.partitionProps.System_partition_name, "system_partition_name")
				case "system_ext":
					assertUnset(a.partitionProps.System_ext_partition_name, "system_ext_partition_name")
				case "system_dlkm":
					assertUnset(a.partitionProps.System_dlkm_partition_name, "system_dlkm_partition_name")
				case "system_other":
					// TODO
				case "product":
					assertUnset(a.partitionProps.Product_partition_name, "product_partition_name")
				case "vendor":
					assertUnset(a.partitionProps.Vendor_partition_name, "vendor_partition_name")
				case "vendor_dlkm":
					assertUnset(a.partitionProps.Vendor_dlkm_partition_name, "vendor_dlkm_partition_name")
				case "odm":
					assertUnset(a.partitionProps.Odm_partition_name, "odm_partition_name")
				case "odm_dlkm":
					assertUnset(a.partitionProps.Odm_dlkm_partition_name, "odm_dlkm_partition_name")
				default:
					ctx.ModuleErrorf("Unsupported sub-partition of super partition: %q", subPartitionType)
				}
			}

			deps = append(deps, info.SuperImage)
		} else {
			ctx.ModuleErrorf("Expected super image dep to provide SuperImageProvider")
		}
	}
	ctx.VisitDirectDepsProxyWithTag(filesystemDepTag, func(m android.ModuleProxy) {
		imageOutput, ok := android.OtherModuleProvider(ctx, m, android.OutputFilesProvider)
		if !ok {
			ctx.ModuleErrorf("Partition module %s doesn't set OutputfilesProvider", m.Name())
		}
		if len(imageOutput.DefaultOutputFiles) != 1 {
			ctx.ModuleErrorf("Partition module %s should provide exact 1 output file", m.Name())
		}
		deps = append(deps, imageOutput.DefaultOutputFiles[0])
	})

	allImagesZip := android.PathForModuleOut(ctx, "all_images.zip")
	allImagesZipBuilder := android.NewRuleBuilder(pctx, ctx)
	cmd := allImagesZipBuilder.Command().BuiltTool("soong_zip")
	for _, dep := range deps {
		cmd.FlagWithArg("-e ", dep.Base())
		cmd.FlagWithInput("-f ", dep)
	}
	cmd.FlagWithOutput("-o ", allImagesZip)
	allImagesZipBuilder.Build("soong_all_images_zip", "all_images.zip")
	a.allImagesZip = allImagesZip

	allImagesStamp := android.PathForModuleOut(ctx, "all_images_stamp")
	var validations android.Paths
	if !ctx.Config().KatiEnabled() && proptools.Bool(a.deviceProps.Main_device) {
		// In soong-only builds, build this module by default.
		// This is the analogue to this make code:
		// https://cs.android.com/android/platform/superproject/main/+/main:build/make/core/main.mk;l=1396;drc=6595459cdd8164a6008335f6372c9f97b9094060
		ctx.Phony("droidcore-unbundled", allImagesStamp)

		deps = append(deps, a.copyFilesToProductOutForSoongOnly(ctx))
	}

	trebleLabelingTestTimestamp := a.buildTrebleLabelingTest(ctx)

	// Treble Labeling tests only for 202604 or later if building system.img.
	if _, exist := a.getFsInfos(ctx)["system"]; exist {
		if ctx.DeviceConfig().PlatformSepolicyVersion() >= "202604" {
			validations = append(validations, trebleLabelingTestTimestamp)
		}
	}

	ctx.Build(pctx, android.BuildParams{
		Rule:        android.Touch,
		Output:      allImagesStamp,
		Implicits:   deps,
		Validations: validations,
	})

	// Checkbuilding it causes soong to make a phony, so you can say `m <module name>`
	ctx.CheckbuildFile(allImagesStamp)

	a.setVbmetaPhonyTargets(ctx)

	a.distFiles(ctx)

	android.SetProvider(ctx, android.AndroidDeviceInfoProvider, android.AndroidDeviceInfo{
		Main_device: android.Bool(a.deviceProps.Main_device),
	})

	if proptools.String(a.partitionProps.Super_partition_name) != "" {
		buildComplianceMetadata(ctx, superPartitionDepTag, filesystemDepTag)
	} else {
		buildComplianceMetadata(ctx, filesystemDepTag)
	}

	complianceMetadataInfo := ctx.ComplianceMetadataInfo()
	pcf := complianceMetadataInfo.GetProductCopyFiles()
	for _, m := range allInstalledModules {
		if info, ok := android.OtherModuleProvider(ctx, m, etc.ProductCopyFilesModuleProvider); ok {
			pcf = append(pcf, info.ProductCopyFileEntries...)
		}
	}
	complianceMetadataInfo.SetProductCopyFiles(pcf)

	// Add the host tools as deps
	if !ctx.Config().KatiEnabled() && proptools.Bool(a.deviceProps.Main_device) {
		for _, hostTool := range ctx.Config().ProductVariables().ProductHostPackages {
			ctx.Phony("droid", android.PathForPhony(ctx, hostTool+"-host"))
		}
	}

	a.checkVintf(ctx)
	a.runApexSepolicyTests(ctx, allInstalledModules)
	a.hostInitVerifierCheck(ctx)
	a.findSharedUIDViolation(ctx)
	a.checkPartitionSizes(ctx)
}

func buildComplianceMetadata(ctx android.ModuleContext, tags ...blueprint.DependencyTag) {
	// Collect metadata from deps
	filesContained := make([]string, 0)
	prebuiltFilesCopied := make([]string, 0)
	platformGeneratedFiles := make([]string, 0)
	for _, tag := range tags {
		ctx.VisitDirectDepsProxyWithTag(tag, func(m android.ModuleProxy) {
			if complianceMetadataInfo, ok := android.OtherModuleProvider(ctx, m, android.ComplianceMetadataProvider); ok {
				filesContained = append(filesContained, complianceMetadataInfo.GetFilesContained()...)
				prebuiltFilesCopied = append(prebuiltFilesCopied, complianceMetadataInfo.GetPrebuiltFilesCopied()...)
				platformGeneratedFiles = append(platformGeneratedFiles, complianceMetadataInfo.GetPlatformGeneratedFiles()...)
			}
		})
	}
	// Merge to module's ComplianceMetadataInfo
	complianceMetadataInfo := ctx.ComplianceMetadataInfo()
	filesContained = append(filesContained, complianceMetadataInfo.GetFilesContained()...)
	sort.Strings(filesContained)
	complianceMetadataInfo.SetFilesContained(filesContained)

	prebuiltFilesCopied = append(prebuiltFilesCopied, complianceMetadataInfo.GetPrebuiltFilesCopied()...)
	sort.Strings(prebuiltFilesCopied)
	complianceMetadataInfo.SetPrebuiltFilesCopied(prebuiltFilesCopied)

	platformGeneratedFiles = append(platformGeneratedFiles, complianceMetadataInfo.GetPlatformGeneratedFiles()...)
	sort.Strings(platformGeneratedFiles)
	complianceMetadataInfo.SetPlatformGeneratedFiles(platformGeneratedFiles)
}

type installedOwnerInfo struct {
	Variation string
	Prebuilt  bool
}

// Returns a list of modules that are installed, which are collected from the dependency
// filesystem and super_image modules. If includeInfoOnly is true it will also find modules
// under system and system_ext fsinfos even though those images is not going to be built.
func (a *androidDevice) allInstalledModules(ctx android.ModuleContext, includeInfoOnly bool) []android.ModuleProxy {
	fsInfoMap := a.getFsInfos(ctx)
	if includeInfoOnly {
		fsInfoOnlyMap := a.getInfoOnlyFsInfos(ctx)
		for partition, fsInfo := range fsInfoOnlyMap {
			fsInfoMap[partition] = fsInfo
		}
	}

	allOwners := make(map[string][]installedOwnerInfo)

	for _, partition := range android.SortedKeys(fsInfoMap) {
		fsInfo := fsInfoMap[partition]
		for _, owner := range fsInfo.Owners.ToList() {
			allOwners[owner.Name] = append(allOwners[owner.Name], installedOwnerInfo{
				Variation: owner.Variation,
				Prebuilt:  owner.Prebuilt,
			})
		}
	}

	ret := []android.ModuleProxy{}
	ctx.WalkDepsProxy(func(mod, _ android.ModuleProxy) bool {
		commonInfo, ok := android.OtherModuleProvider(ctx, mod, android.CommonModuleInfoProvider)
		if !(ok && commonInfo.ExportedToMake) {
			return false
		}
		prebuiltInfo := android.OtherModuleProviderOrDefault(ctx, mod, android.PrebuiltInfoProvider)
		name := android.OtherModuleNameWithPossibleOverride(ctx, mod)
		if variations, ok := allOwners[name]; ok &&
			android.InList(installedOwnerInfo{
				Variation: ctx.OtherModuleSubDir(mod),
				Prebuilt:  prebuiltInfo.IsPrebuilt,
			}, variations) {
			ret = append(ret, mod)
		}
		return true
	})

	// Remove duplicates
	ret = android.FirstUniqueInPlace(ret)

	// Sort the modules by their names and variants
	slices.SortFunc(ret, func(a, b android.ModuleProxy) int {
		return cmp.Compare(a.String(), b.String())
	})
	return ret
}

func (a *androidDevice) buildSymbolsZip(ctx android.ModuleContext, allInstalledModules []android.ModuleProxy) {
	a.symbolsZipFile = android.PathForModuleOut(ctx, "symbols.zip")
	a.symbolsMappingFile = android.PathForModuleOut(ctx, "symbols-mapping.textproto")
	allInstalledSymbolsPaths, allInstalledSymbolsMappingPaths := android.BuildSymbolsZip(ctx, allInstalledModules, a.symbolsZipFile, a.symbolsMappingFile)
	if !ctx.Config().KatiEnabled() {
		ctx.Phony("symbols-files", allInstalledSymbolsPaths...)
		ctx.Phony("symbols-mappings", allInstalledSymbolsMappingPaths...)
		ctx.Phony("droidcore-unbundled", android.PathForPhony(ctx, "symbols-files"), android.PathForPhony(ctx, "symbols-mappings"))
	}
}

func (a *androidDevice) distInstalledFiles(ctx android.ModuleContext) {
	distInstalledFilesJsonAndTxt := func(installedFiles InstalledFilesStruct) {
		if installedFiles.Json != nil {
			ctx.DistForGoal("droidcore-unbundled", installedFiles.Json)
		}
		if installedFiles.Txt != nil {
			ctx.DistForGoal("droidcore-unbundled", installedFiles.Txt)
		}
	}

	fsInfoMap := a.getFsInfos(ctx)
	for _, partition := range android.SortedKeys(fsInfoMap) {
		// installed-files-*{.txt | .json} is not disted for userdata partition
		if partition == "userdata" {
			continue
		}
		fsInfo := fsInfoMap[partition]
		for _, installedFiles := range fsInfo.InstalledFilesDepSet.ToList() {
			distInstalledFilesJsonAndTxt(installedFiles)
		}
	}
}

func (a *androidDevice) distFiles(ctx android.ModuleContext) {
	if !ctx.Config().KatiEnabled() && proptools.Bool(a.deviceProps.Main_device) {
		a.distInstalledFiles(ctx)

		namePrefix := ""
		if ctx.Config().HasDeviceProduct() {
			namePrefix = ctx.Config().DeviceProduct() + "-"
		}
		ctx.DistForGoalWithFilenameTag("droidcore-unbundled", a.proguardZips.DictZip, namePrefix+a.proguardZips.DictZip.Base())
		ctx.DistForGoalWithFilenameTag("droidcore-unbundled", a.proguardZips.DictMapping, namePrefix+a.proguardZips.DictMapping.Base())
		ctx.DistForGoalWithFilenameTag("droidcore-unbundled", a.proguardZips.UsageZip, namePrefix+a.proguardZips.UsageZip.Base())

		ctx.DistForGoalWithFilenameTag("droidcore-unbundled", a.symbolsZipFile, namePrefix+a.symbolsZipFile.Base())
		ctx.DistForGoalWithFilenameTag("droidcore-unbundled", a.symbolsMappingFile, namePrefix+a.symbolsMappingFile.Base())

		if a.androidInfoTxt != nil {
			ctx.DistForGoal("droidcore-unbundled", a.androidInfoTxt)
		}
		if a.miscInfo != nil {
			ctx.DistForGoal("droidcore-unbundled", a.miscInfo)
			if a.partitionProps.Super_partition_name != nil {
				ctx.DistForGoalWithFilename("dist_files", a.miscInfo, "super_misc_info.txt")
			}
		}
		if a.targetFilesZip != nil {
			ctx.Phony("target-files-package", a.targetFilesZip)
			ctx.DistForGoalWithFilenameTag("target-files-package", a.targetFilesZip, namePrefix+a.targetFilesZip.Base())
			ctx.DistForGoalWithFilenameTag("droidcore-unbundled", a.targetFilesZip, namePrefix+a.targetFilesZip.Base())
		}
		if a.updatePackage != nil {
			ctx.DistForGoalWithFilenameTag("updatepackage", a.updatePackage, namePrefix+a.updatePackage.Base())
			ctx.DistForGoalWithFilenameTag("droidcore-unbundled", a.updatePackage, namePrefix+a.updatePackage.Base())
		}
		if a.otaFilesZip != nil {
			ctx.Phony("otapackage", a.otaFilesZip)
			ctx.DistForGoalWithFilenameTag("droidcore-unbundled", a.otaFilesZip, namePrefix+a.otaFilesZip.Base())
			ctx.DistForGoalWithFilenameTag("droidcore-unbundled", a.otaMetadata, namePrefix+a.otaMetadata.Base())
		}
		if a.partialOtaFilesZip != nil {
			ctx.Phony("partialotapackage", a.partialOtaFilesZip)
			ctx.DistForGoalWithFilenameTag("droidcore-unbundled", a.partialOtaFilesZip, namePrefix+a.partialOtaFilesZip.Base())
		}
		if a.jacocoZip != nil {
			ctx.DistForGoal("dist_files", a.jacocoZip)
		}
		// radio
		if a.deviceProps.Radio_partition_name != nil {
			radio := ctx.GetDirectDepProxyWithTag(*a.deviceProps.Radio_partition_name, radioDepTag)
			files := android.OutputFilesForModule(ctx, radio, "")
			for _, file := range files {
				// The radio files are disted stanadlone, outside img.zip
				ctx.DistForGoal("droidcore-unbundled", file)
			}
		}
		// bootloader
		if a.deviceProps.Bootloader != nil {
			bootloader := ctx.GetDirectDepProxyWithTag(*a.deviceProps.Bootloader, bootloaderDepTag)
			files := android.OutputFilesForModule(ctx, bootloader, "")
			for _, file := range files {
				// The bootloader files are disted stanadlone, outside img.zip
				ctx.DistForGoal("droidcore-unbundled", file)
			}
		}
		// vendor_boot-debug
		if a.partitionProps.Vendor_boot_debug_partition_name != nil {
			bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(a.partitionProps.Vendor_boot_debug_partition_name), filesystemDepTag)
			bootImgInfo := android.OtherModuleProviderOrDefault(ctx, bootImg, BootimgInfoProvider)
			ctx.DistForGoal("droidcore-unbundled", bootImgInfo.Output)
		}
		// vendor_boot-test-harness
		if a.partitionProps.Vendor_boot_test_harness_partition_name != nil {
			bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(a.partitionProps.Vendor_boot_test_harness_partition_name), filesystemDepTag)
			bootImgInfo := android.OtherModuleProviderOrDefault(ctx, bootImg, BootimgInfoProvider)
			ctx.DistForGoal("droidcore-unbundled", bootImgInfo.Output)
		}

		if a.withLicenseFile != nil {
			ctx.Phony("with-license", a.withLicenseFile)
			ctx.DistForGoalWithFilename("with-license", a.withLicenseFile, a.withLicenseDistName)
		}
	}
}

func (a *androidDevice) MakeVars(_ android.MakeVarsModuleContext) []android.ModuleMakeVarsValue {
	if proptools.Bool(a.deviceProps.Main_device) {
		return []android.ModuleMakeVarsValue{{"SOONG_ONLY_ALL_IMAGES_ZIP", a.allImagesZip.String()}}
	}
	return nil
}

// Helper structs for target_files.zip creation
type targetFilesZipCopy struct {
	srcModule  *string
	destSubdir string
}

type targetFilesystemZipCopy struct {
	fsInfo     FilesystemInfo
	destSubdir string
}

func (a *androidDevice) buildTargetFilesZip(ctx android.ModuleContext, allInstalledModules []android.ModuleProxy) {
	targetFilesDir := android.PathForModuleOut(ctx, "target_files_dir")
	targetFilesDirStamp := android.PathForModuleOut(ctx, "target_files_dir.stamp")
	targetFilesZip := android.PathForModuleOut(ctx, "target_files.zip")
	otaFilesZip := android.PathForModuleOut(ctx, "ota.zip")
	otaMetadata := android.PathForModuleOut(ctx, "ota_metadata")
	partialOtaFilesZip := android.PathForModuleOut(ctx, "partial-ota.zip")

	builder := android.NewRuleBuilder(pctx, ctx)
	builder.Command().Textf("rm -rf %s", targetFilesDirStamp.String())
	builder.Command().Textf("rm -rf %s", targetFilesDir.String())
	builder.Command().Textf("mkdir -p %s", targetFilesDir.String())
	toCopy := []targetFilesZipCopy{
		targetFilesZipCopy{a.partitionProps.System_partition_name, "SYSTEM"},
		targetFilesZipCopy{a.partitionProps.System_ext_partition_name, "SYSTEM_EXT"},
		targetFilesZipCopy{a.partitionProps.Product_partition_name, "PRODUCT"},
		targetFilesZipCopy{a.partitionProps.Vendor_partition_name, "VENDOR"},
		targetFilesZipCopy{a.partitionProps.Odm_partition_name, "ODM"},
		targetFilesZipCopy{a.partitionProps.System_dlkm_partition_name, "SYSTEM_DLKM"},
		targetFilesZipCopy{a.partitionProps.Vendor_dlkm_partition_name, "VENDOR_DLKM"},
		targetFilesZipCopy{a.partitionProps.Odm_dlkm_partition_name, "ODM_DLKM"},
		targetFilesZipCopy{a.partitionProps.Init_boot_partition_name, "BOOT/RAMDISK"},
		targetFilesZipCopy{a.partitionProps.Init_boot_partition_name, "INIT_BOOT/RAMDISK"},
		targetFilesZipCopy{a.partitionProps.Ramdisk_partition_name, "BOOT/RAMDISK"}, // For products without init_boot
		targetFilesZipCopy{a.partitionProps.Vendor_boot_partition_name, "VENDOR_BOOT/RAMDISK"},
		targetFilesZipCopy{a.partitionProps.Vendor_kernel_boot_partition_name, "VENDOR_KERNEL_BOOT/RAMDISK"},
	}

	filesystemsToCopy := []targetFilesystemZipCopy{}
	for _, zipCopy := range toCopy {
		if zipCopy.srcModule == nil {
			continue
		}
		filesystemsToCopy = append(
			filesystemsToCopy,
			targetFilesystemZipCopy{a.getFilesystemInfo(ctx, *zipCopy.srcModule), zipCopy.destSubdir},
		)
	}
	// Get additional filesystems from super_partition dependency
	if a.partitionProps.Super_partition_name != nil {
		superPartition := ctx.GetDirectDepProxyWithTag(*a.partitionProps.Super_partition_name, superPartitionDepTag)
		if info, ok := android.OtherModuleProvider(ctx, superPartition, SuperImageProvider); ok {
			for _, partition := range android.SortedKeys(info.SubImageInfo) {
				filesystemsToCopy = append(
					filesystemsToCopy,
					targetFilesystemZipCopy{info.SubImageInfo[partition], strings.ToUpper(partition)},
				)
			}
		} else {
			ctx.ModuleErrorf("Super partition %s does set SuperImageProvider\n", superPartition.Name())
		}
	}

	for _, toCopy := range filesystemsToCopy {
		rootDirString := toCopy.fsInfo.RootDir.String()
		if toCopy.destSubdir == "SYSTEM" {
			rootDirString = rootDirString + "/system"
		}
		builder.Command().Textf("mkdir -p %s/%s", targetFilesDir.String(), toCopy.destSubdir)
		builder.Command().
			BuiltTool("acp").
			Textf("-rd %s/. %s/%s", rootDirString, targetFilesDir, toCopy.destSubdir).
			Implicit(toCopy.fsInfo.Output) // so that the staging dir is built
		for _, extraRootDir := range toCopy.fsInfo.ExtraRootDirs {
			builder.Command().
				BuiltTool("acp").
				Textf("-rd %s/. %s/%s", extraRootDir, targetFilesDir, toCopy.destSubdir).
				Implicit(toCopy.fsInfo.Output) // so that the staging dir is built
		}

		if toCopy.destSubdir == "SYSTEM" {
			// Create the ROOT partition in target_files.zip
			builder.Command().Textf("rsync --links --exclude=system/* %s/ -r %s/ROOT", toCopy.fsInfo.RootDir, targetFilesDir.String())
			// Add a duplicate rule to assemble the ROOT/ directory in separate intermediates.
			// The output timestamp will be an input to a separate fs_config call.
			a.rootDirForFsConfig = android.PathForModuleOut(ctx, "root_dir_for_fs_config").String()
			rootDirBuilder := android.NewRuleBuilder(pctx, ctx)
			rootDirForFsConfigTimestamp := android.PathForModuleOut(ctx, "root_dir_for_fs_config.timestamp")
			rootDirBuilder.Command().Textf("rsync --links --exclude=system/* %s/ -r %s", toCopy.fsInfo.RootDir, a.rootDirForFsConfig).
				Implicit(toCopy.fsInfo.Output).
				Text("&& touch").
				Output(rootDirForFsConfigTimestamp)
			rootDirBuilder.Build("assemble_root_dir_for_fs_config", "Assemble ROOT/ for fs_config")
			a.rootDirForFsConfigTimestamp = rootDirForFsConfigTimestamp
		}
	}
	// Copy cmdline, kernel etc. files of boot images
	if a.partitionProps.Vendor_boot_partition_name != nil {
		bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(a.partitionProps.Vendor_boot_partition_name), filesystemDepTag)
		bootImgInfo, _ := android.OtherModuleProvider(ctx, bootImg, BootimgInfoProvider)
		builder.Command().Textf("mkdir -p %s/VENDOR_BOOT", targetFilesDir)
		builder.Command().Textf("echo %s > %s/VENDOR_BOOT/cmdline", proptools.ShellEscape(strings.Join(bootImgInfo.Cmdline, " ")), targetFilesDir)
		builder.Command().Textf("echo %s > %s/VENDOR_BOOT/vendor_cmdline", proptools.ShellEscape(strings.Join(bootImgInfo.Cmdline, " ")), targetFilesDir)
		if bootImgInfo.Dtb != nil {
			builder.Command().Textf("cp ").Input(bootImgInfo.Dtb).Textf(" %s/VENDOR_BOOT/dtb", targetFilesDir)
		}
		if bootImgInfo.Bootconfig != nil {
			builder.Command().Textf("cp ").Input(bootImgInfo.Bootconfig).Textf(" %s/VENDOR_BOOT/vendor_bootconfig", targetFilesDir)
		}
	}
	if a.partitionProps.Vendor_kernel_boot_partition_name != nil {
		bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(a.partitionProps.Vendor_kernel_boot_partition_name), filesystemDepTag)
		bootImgInfo, _ := android.OtherModuleProvider(ctx, bootImg, BootimgInfoProvider)
		if bootImgInfo.Dtb != nil {
			builder.Command().Textf("cp ").Input(bootImgInfo.Dtb).Textf(" %s/VENDOR_KERNEL_BOOT/dtb", targetFilesDir)
			// Make packaging copies dtb to recovery subdir.
			// https://source.corp.google.com/h/googleplex-android/platform/build/+/06d7d8ca0c4fd1e90c7b0aa64c4107ce3f3b1126:core/Makefile;l=6663-6665;bpv=1;bpt=0;drc=9d8019e0c19db397f4ce03ba5abdb9df614adc7d
			if ctx.DeviceConfig().BoardMoveRecoveryResourcesToVendorBoot() {
				builder.Command().Textf("cp ").Input(bootImgInfo.Dtb).Textf(" %s/VENDOR_BOOT/dtb", targetFilesDir)
			}
		}
	}

	if a.partitionProps.Boot_partition_name != nil {
		bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(a.partitionProps.Boot_partition_name), filesystemDepTag)
		bootImgInfo, ok := android.OtherModuleProvider(ctx, bootImg, BootimgInfoProvider)
		if !ok {
			ctx.PropertyErrorf("boot_partition_name", "Expected a BootimgInfoProvider")
		}
		builder.Command().Textf("mkdir -p %s/BOOT && echo %s > %s/BOOT/cmdline", targetFilesDir, proptools.ShellEscape(strings.Join(bootImgInfo.Cmdline, " ")), targetFilesDir)
		if bootImgInfo.Dtb != nil {
			builder.Command().Textf("cp ").Input(bootImgInfo.Dtb).Textf(" %s/BOOT/dtb", targetFilesDir)
		}
		if bootImgInfo.Kernel != nil && !bootImgInfo.IsPrebuilt {
			builder.Command().Textf("cp ").Input(bootImgInfo.Kernel).Textf(" %s/BOOT/kernel", targetFilesDir)
			// Even though kernel is not used to build vendor_boot, copy the kernel to VENDOR_BOOT to match the behavior of make packaging.
			builder.Command().Textf("cp ").Input(bootImgInfo.Kernel).Textf(" %s/VENDOR_BOOT/kernel", targetFilesDir)
		}
		if bootImgInfo.Bootconfig != nil {
			builder.Command().Textf("cp ").Input(bootImgInfo.Bootconfig).Textf(" %s/BOOT/bootconfig", targetFilesDir)
		}
	}

	if a.androidInfoTxt != nil {
		builder.Command().Textf("mkdir -p %s/OTA", targetFilesDir)
		builder.Command().Textf("cp ").Input(a.androidInfoTxt).Textf(" %s/OTA/android-info.txt", targetFilesDir)
	}

	builder.Command().Textf("mkdir -p %s/IMAGES", targetFilesDir.String())
	if a.deviceProps.Bootloader != nil {
		bootloader := ctx.GetDirectDepProxyWithTag(*a.deviceProps.Bootloader, bootloaderDepTag)
		if vbmetaPartitionInfo := android.OtherModuleProviderOrDefault(ctx, bootloader, vbmetaPartitionsProvider); len(vbmetaPartitionInfo) > 0 {
			// Bootloader with AB ota partitions are copied to RADIO/ subdirectory.
			// This matches the make implementation.
			files := android.OutputFilesForModule(ctx, bootloader, "")
			builder.Command().
				Textf("mkdir -p %s/RADIO && cp -t %s/RADIO ", targetFilesDir, targetFilesDir).
				Inputs(files)
		} else {
			bootloaderFile := android.OutputFilesForModule(ctx, bootloader, "")
			if len(bootloaderFile) != 1 {
				ctx.ModuleErrorf("Expected bootloader to be a single file")
			}
			builder.Command().Textf("cp ").Input(bootloaderFile[0]).Textf(" %s/IMAGES/bootloader", targetFilesDir.String())
		}
	}
	if a.partitionProps.Boot_16k_partition_name != nil {
		bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(a.partitionProps.Boot_16k_partition_name), filesystemDepTag)
		if bootImgInfo := android.OtherModuleProviderOrDefault(ctx, bootImg, BootimgInfoProvider); bootImgInfo.Output != nil {
			// The primary boot.img is generated by add_img_to_target_files from misc_info.txt,
			// but boot_16k.img is copied from the installation/intermediates directory.
			builder.Command().Text("cp").Input(bootImgInfo.Output).Textf(" %s/IMAGES/", targetFilesDir)
			// Make packaging copies the 16k kernel to PREBUILT_IMAGES. Port this behavior here.
			builder.Command().
				Textf("mkdir -p %s/PREBUILT_IMAGES && cp", targetFilesDir).
				Input(bootImgInfo.Kernel).Textf(" %s/PREBUILT_IMAGES/kernel_16k", targetFilesDir)
		}
	}
	if a.deviceProps.Radio_partition_name != nil {
		radio := ctx.GetDirectDepProxyWithTag(*a.deviceProps.Radio_partition_name, radioDepTag)
		files := android.OutputFilesForModule(ctx, radio, "")
		builder.Command().
			Textf("mkdir -p %s/RADIO && cp -t %s/RADIO ", targetFilesDir, targetFilesDir).
			Inputs(files)
	}
	if a.deviceProps.Pvmfw.Image != nil {
		pvmfwImg := android.PathForModuleSrc(ctx, proptools.String(a.deviceProps.Pvmfw.Image))
		builder.Command().Textf("mkdir -p %s/PREBUILT_IMAGES/ && cp", targetFilesDir.String()).Input(pvmfwImg).Textf(" %s/PREBUILT_IMAGES/pvmfw.img", targetFilesDir.String())
	}
	if a.deviceProps.Pvmfw.Binary != nil {
		pvmfwBin := android.PathForModuleSrc(ctx, proptools.String(a.deviceProps.Pvmfw.Binary))
		builder.Command().Textf("mkdir -p %s/PVMFW/ && cp", targetFilesDir.String()).Input(pvmfwBin).Textf(" %s/PVMFW/pvmfw_bin", targetFilesDir.String())
	}
	if a.deviceProps.Pvmfw.Avbkey != nil {
		pvbmfwAvbkey := android.PathForModuleSrc(ctx, proptools.String(a.deviceProps.Pvmfw.Avbkey))
		builder.Command().Textf("mkdir -p %s/PREBUILT_IMAGES/ && cp", targetFilesDir.String()).Input(pvbmfwAvbkey).Textf(" %s/PREBUILT_IMAGES/pvmfw_embedded.avbpubkey", targetFilesDir.String())
	}
	if a.deviceProps.Ramdisk_16k != nil {
		ramdisk16k := ctx.GetDirectDepProxyWithTag(proptools.String(a.deviceProps.Ramdisk_16k), ramdisk16kDepTag)
		info := android.OtherModuleProviderOrDefault(ctx, ramdisk16k, FilesystemProvider)
		builder.Command().Textf("mkdir -p %s/PREBUILT_IMAGES/ && cp", targetFilesDir.String()).Input(info.Output).Textf(" %s/PREBUILT_IMAGES/ramdisk_16k.img", targetFilesDir.String())
	}

	// Force copy build.prop for system partition even there's no system partition for this product to reflect the logic in make.
	if _, exist := a.getFsInfos(ctx)["system"]; !exist {
		systemBuildProp := ctx.GetDirectDepProxyWithTag("system-build.prop", filesystemDepTag)
		if !systemBuildProp.IsNil() {
			file := android.OutputFileForModule(ctx, systemBuildProp, "")
			builder.Command().Textf("mkdir -p %s/SYSTEM/ && cp", targetFilesDir.String()).Input(file).Textf(" %s/SYSTEM/build.prop", targetFilesDir.String())
		}
	}

	a.copyPrebuiltImages(ctx, builder, targetFilesDir)

	a.copyVendorRamdiskFragments(ctx, builder, targetFilesDir)

	a.copyMetadataToTargetZip(ctx, builder, targetFilesDir, allInstalledModules)

	builder.Command().Text("touch ").Output(targetFilesDirStamp)
	builder.Build("target_files_dir", "Build target_files staging directory")

	zipBuilder := android.NewRuleBuilder(pctx, ctx)
	zipBuilder.Command().
		BuiltTool("soong_zip").
		Text("-d").
		FlagWithOutput("-o ", targetFilesZip).
		FlagWithArg("-C ", targetFilesDir.String()).
		FlagWithArg("-D ", targetFilesDir.String()).
		Text("-sha256").
		Implicit(targetFilesDirStamp)
	zipBuilder.Build("target_files", "Build target_files.zip")
	a.targetFilesZip = targetFilesZip

	if ctx.Config().BuildOTAPackage() {
		otaBuilder := android.NewRuleBuilder(pctx, ctx)
		pem, _ := ctx.Config().DefaultAppCertificate(ctx)
		pemWithoutFileExt := strings.TrimSuffix(pem.String(), ".x509.pem")
		otaBuilder.Command().
			BuiltTool("ota_from_target_files").
			Flag("--verbose").
			FlagWithArg("-k ", pemWithoutFileExt).
			FlagWithOutput("--output_metadata_path ", otaMetadata).
			Text(targetFilesDir.String()).
			Output(otaFilesZip).
			Implicit(ctx.Config().HostToolPath(ctx, "delta_generator")).
			Implicit(ctx.Config().HostToolPath(ctx, "checkvintf")).
			Implicit(targetFilesDirStamp)
		otaBuilder.Build("ota_zip", "Build ota from target files")
		a.otaFilesZip = otaFilesZip
		a.otaMetadata = otaMetadata

		// Partial ota
		if len(a.deviceProps.Partial_ota_update_partitions) > 0 {
			partialOtaBuilder := android.NewRuleBuilder(pctx, ctx)
			partialOtaBuilder.Command().
				BuiltTool("ota_from_target_files").
				Flag("--verbose").
				FlagWithArg("-k ", pemWithoutFileExt).
				FlagForEachArg("--partial ", a.deviceProps.Partial_ota_update_partitions).
				Text(targetFilesDir.String()).
				Output(partialOtaFilesZip).
				Implicit(targetFilesDirStamp)
			partialOtaBuilder.Build("partial_ota_zip", "Build partial ota from target files")
			a.partialOtaFilesZip = partialOtaFilesZip
		}
	}
}

// TODO: pvmfw, ...
func (a *androidDevice) copyPrebuiltImages(ctx android.ModuleContext, builder *android.RuleBuilder, targetFilesDir android.Path) {
	if a.partitionProps.Boot_partition_name != nil {
		bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(a.partitionProps.Boot_partition_name), filesystemDepTag)
		if bootImgInfo := android.OtherModuleProviderOrDefault(ctx, bootImg, BootimgInfoProvider); bootImgInfo.IsPrebuilt {
			builder.Command().Textf("mkdir -p %s/PREBUILT_IMAGES/", targetFilesDir)
			builder.Command().Text("cp").Input(bootImgInfo.Output).Textf(" %s/PREBUILT_IMAGES/", targetFilesDir)
		}
	}
	// Copy dtbo.img.
	// All products with dtbo.img use a prebuilt.
	if a.deviceProps.Dtbo_image != nil {
		dtbo := ctx.GetDirectDepProxyWithTag(*a.deviceProps.Dtbo_image, dtboDepTag)
		img := android.OutputFilesForModule(ctx, dtbo, "")[0]
		// Copy to PREBUILT_IMAGES/
		// add_img_to_target_files.py will create another copy in IMAGES/
		builder.Command().Textf("mkdir -p %s/PREBUILT_IMAGES && cp", targetFilesDir).Input(img).Textf(" %s/PREBUILT_IMAGES/", targetFilesDir)
	}
	// Copy dtbo_16k.img.
	// All products with dtbo.img use a prebuilt.
	if a.deviceProps.Dtbo_image_16k != nil {
		dtbo := ctx.GetDirectDepProxyWithTag(*a.deviceProps.Dtbo_image_16k, dtboDepTag)
		img := android.OutputFilesForModule(ctx, dtbo, "")[0]
		// Copy directly to IMAGES/
		// add_img_to_target_files.py does not support dtbo_16k
		builder.Command().Text("cp").Input(img).Textf(" %s/IMAGES/", targetFilesDir)
	}
}

// partial implementation of vendor ramdisk fragments in target_files.zip
func (a *androidDevice) copyVendorRamdiskFragments(ctx android.ModuleContext, builder *android.RuleBuilder, targetFilesDir android.Path) {
	var vendorRamdiskFragments []string
	// TODO (b/428047677): Re-implement 16k as a vendor ramdisk fragment.
	// TODO (b/435530838): Verify vendor_boot.img in $ANDROID_PRODUCT_OUT is bit-identical.
	if a.deviceProps.Ramdisk_16k != nil {
		vendorRamdiskFragments = append(vendorRamdiskFragments, "16K")
		ramdisk16k := ctx.GetDirectDepProxyWithTag(proptools.String(a.deviceProps.Ramdisk_16k), ramdisk16kDepTag)
		info := android.OtherModuleProviderOrDefault(ctx, ramdisk16k, FilesystemProvider)
		builder.Command().
			Textf("mkdir -p %s/VENDOR_BOOT/RAMDISK_FRAGMENTS/16K/", targetFilesDir.String()).
			Text(" && cp").
			Input(info.Output).
			Textf(" %s/VENDOR_BOOT/RAMDISK_FRAGMENTS/16K/prebuilt_ramdisk", targetFilesDir.String())

		builder.Command().
			Textf("echo --ramdisk_name 16K > %s/VENDOR_BOOT/RAMDISK_FRAGMENTS/16K/mkbootimg_args", targetFilesDir)
	}
	if a.partitionProps.Vendor_boot_partition_name != nil {
		vendorBootPartition := ctx.GetDirectDepProxyWithTag(*a.partitionProps.Vendor_boot_partition_name, filesystemDepTag)
		if info, ok := android.OtherModuleProvider(ctx, vendorBootPartition, ramdiskFragmentsInfoProvider); ok {
			for _, fragmentInfo := range info {
				vendorRamdiskFragments = append(vendorRamdiskFragments, fragmentInfo.Ramdisk_name)
				// Copy the files to VENDOR_BOOT/RAMDISK_FRAGMENTS
				builder.Command().
					Textf("mkdir -p %s/VENDOR_BOOT/RAMDISK_FRAGMENTS/%s/RAMDISK && ", targetFilesDir, fragmentInfo.Ramdisk_name).
					BuiltTool("acp").
					Textf("-rd %s/. %s/VENDOR_BOOT/RAMDISK_FRAGMENTS/%s/RAMDISK", fragmentInfo.RootDir.String(), targetFilesDir, fragmentInfo.Ramdisk_name).
					Implicit(fragmentInfo.Output) // so that the staging dir is built
				// Create a file for mkbootimg
				builder.Command().Textf(
					"echo \"--ramdisk_type %s --ramdisk_name %s\" > %s/VENDOR_BOOT/RAMDISK_FRAGMENTS/%s/mkbootimg_args",
					strings.ToUpper(fragmentInfo.Ramdisk_name),
					fragmentInfo.Ramdisk_name,
					targetFilesDir,
					fragmentInfo.Ramdisk_name,
				)
			}
		} else {
			ctx.ModuleErrorf("Vendor boot partition %s does set BootimgInfoProvider\n", vendorBootPartition.Name())
		}
	}

	if len(vendorRamdiskFragments) > 0 {
		builder.Command().Textf("echo %s > %s/VENDOR_BOOT/vendor_ramdisk_fragments", strings.Join(vendorRamdiskFragments, " "), targetFilesDir)
	}
}

func writeFileWithNewLines(ctx android.ModuleContext, path android.WritablePath, contents []string) {
	builder := &strings.Builder{}
	for i, content := range contents {
		builder.WriteString(content)
		// Do not write a new line at the end
		if i < len(contents)-1 {
			builder.WriteString("\n")
		}
	}
	android.WriteFileRule(ctx, path, builder.String())
}

func (a *androidDevice) copyMetadataToTargetZip(ctx android.ModuleContext, builder *android.RuleBuilder,
	targetFilesDir android.ModuleOutPath, allInstalledModules []android.ModuleProxy) {

	// Create a META/ subdirectory
	builder.Command().Textf("mkdir -p %s/META", targetFilesDir.String())
	if proptools.Bool(a.deviceProps.Ab_ota_updater) {
		ctx.VisitDirectDepsProxyWithTag(targetFilesMetadataDepTag, func(child android.ModuleProxy) {
			info, _ := android.OtherModuleProvider(ctx, child, android.OutputFilesProvider)
			builder.Command().Textf("cp").Inputs(info.DefaultOutputFiles).Textf(" %s/META/", targetFilesDir.String())
		})
		builder.Command().Textf("cp").Input(android.PathForSource(ctx, "external/zucchini/version_info.h")).Textf(" %s/META/zucchini_config.txt", targetFilesDir.String())
		builder.Command().Textf("cp").Input(android.PathForSource(ctx, "system/update_engine/update_engine.conf")).Textf(" %s/META/update_engine_config.txt", targetFilesDir.String())
		// erofs_default_compress_hints.txt
		fsInfos := a.getFsInfos(ctx)
		if fsInfos["system"].ErofsCompressHints != nil {
			builder.Command().Textf("cp").Input(fsInfos["system"].ErofsCompressHints).Textf(" %s/META/erofs_default_compress_hints.txt", targetFilesDir.String())
		} else {
			// Use other partitions' ErofsCompressHints if system partition's not exist.
			for _, partition := range android.SortedKeys(fsInfos) {
				if fsInfos[partition].ErofsCompressHints != nil {
					builder.Command().Textf("cp").Input(fsInfos[partition].ErofsCompressHints).Textf(" %s/META/erofs_default_compress_hints.txt", targetFilesDir.String())
					break
				}
			}
		}

		// ab_partitions.txt
		abPartitionsSorted := android.SortedUniqueStrings(a.deviceProps.Ab_ota_partitions)
		if len(abPartitionsSorted) > 0 {
			abPartitionsFilePath := android.PathForModuleOut(ctx, "target_files_tmp", "ab_partitions.txt")
			writeFileWithNewLines(ctx, abPartitionsFilePath, abPartitionsSorted)
			builder.Command().Textf("cp").Input(abPartitionsFilePath).Textf(" %s/META/", targetFilesDir)
		}
		// otakeys.txt
		abOtaKeysSorted := android.SortedUniqueStrings(a.deviceProps.Ab_ota_keys)
		abOtaKeysFilePath := android.PathForModuleOut(ctx, "target_files_tmp", "otakeys.txt")
		writeFileWithNewLines(ctx, abOtaKeysFilePath, abOtaKeysSorted)
		builder.Command().Textf("cp").Input(abOtaKeysFilePath).Textf(" %s/META/", targetFilesDir)
		// postinstall_config.txt
		abOtaPostInstallConfigFilePath := android.PathForModuleOut(ctx, "target_files_tmp", "postinstall_config.txt")
		writeFileWithNewLines(ctx, abOtaPostInstallConfigFilePath, a.deviceProps.Ab_ota_postinstall_config)
		builder.Command().Textf("cp").Input(abOtaPostInstallConfigFilePath).Textf(" %s/META/", targetFilesDir)
		// selinuxfc
		fileContextsModule := ctx.GetDirectDepProxyWithTag("file_contexts_bin_gen", fileContextsDepTag)
		outputFiles, ok := android.OtherModuleProvider(ctx, fileContextsModule, android.OutputFilesProvider)
		if !ok || len(outputFiles.DefaultOutputFiles) != 1 {
			ctx.ModuleErrorf("Expected exactly 1 output file from file_contexts_bin_gen")
		} else {
			selinuxFc := outputFiles.DefaultOutputFiles[0]
			if selinuxFc != nil {
				builder.Command().Textf("cp").Input(selinuxFc).Textf(" %s/META/file_contexts.bin", targetFilesDir.String())
			}
		}
	}
	// Copy $partition_filesystem_config.txt
	fsInfos := a.getFsInfos(ctx)
	for _, partition := range android.SortedKeys(fsInfos) {
		if fsInfos[partition].FilesystemConfig == nil {
			continue
		}
		if android.InList(partition, []string{"userdata"}) {
			continue
		}
		if partition != "vendor_ramdisk" {
			// vendor_ramdisk will be handled separately.
			builder.Command().Textf("cp").Input(fsInfos[partition].FilesystemConfig).Textf(" %s/META/%s", targetFilesDir.String(), a.filesystemConfigNameForTargetFiles(partition))
		}
		if partition == "ramdisk" {
			// Create an additional copy at boot_filesystem_config.txt
			builder.Command().Textf("cp").Input(fsInfos[partition].FilesystemConfig).Textf(" %s/META/boot_filesystem_config.txt", targetFilesDir.String())
		}
		if partition == "system" {
			// Create root_filesystem_config from the assembled ROOT/ intermediates directory
			a.generateFilesystemConfigForTargetFiles(ctx, builder, a.rootDirForFsConfigTimestamp, targetFilesDir.String(), a.rootDirForFsConfig, "root_filesystem_config.txt")
		}
		if partition == "vendor_ramdisk" {
			// Create vendor_boot_filesystem_config from the assembled VENDOR_BOOT/RAMDISK intermediates directory
			vendorRamdiskStagingDir := targetFilesDir.String() + "/VENDOR_BOOT/RAMDISK"
			vendorRamdiskFsConfigOut := targetFilesDir.String() + "/META/vendor_boot_filesystem_config.txt"
			fsConfigBin := ctx.Config().HostToolPath(ctx, "fs_config")
			builder.Command().Textf(
				`(cd %s; find . -type d | sed 's,$,/,'; find . \! -type d) | cut -c 3- | sort | sed 's,^,,' | %s -C -D %s -R \"\" > %s`,
				vendorRamdiskStagingDir, fsConfigBin, vendorRamdiskStagingDir, vendorRamdiskFsConfigOut).
				Implicit(fsConfigBin)
		}
	}
	if a.partitionProps.Ramdisk_partition_name != nil {
		partition := ctx.GetDirectDepProxyWithTag(*a.partitionProps.Ramdisk_partition_name, filesystemDepTag)
		if info, ok := android.OtherModuleProvider(ctx, partition, FilesystemProvider); ok {
			builder.Command().Textf("cp").Input(info.FilesystemConfig).Textf(" %s/META/boot_filesystem_config.txt", targetFilesDir.String())
		} else {
			ctx.ModuleErrorf("Ramdisk partition %s does not set FilesystemProvider\n", partition.Name())
		}
	}

	// Copy ramdisk_node_list
	if proptools.String(a.deviceProps.Ramdisk_node_list) != "" {
		ramdiskNodeList := android.PathForModuleSrc(ctx, proptools.String(a.deviceProps.Ramdisk_node_list))
		builder.Command().Textf("cp").Input(ramdiskNodeList).Textf(" %s/META/", targetFilesDir.String())
	}
	// Copy releasetools.py
	if proptools.String(a.deviceProps.Releasetools_extension) != "" {
		releaseTools := android.PathForModuleSrc(ctx, proptools.String(a.deviceProps.Releasetools_extension))
		builder.Command().Textf("cp").Input(releaseTools).Textf(" %s/META/", targetFilesDir.String())
	}
	// apexkeys.txt
	var installedApexKeys []android.Path
	for _, installedModule := range allInstalledModules {
		if info, ok := android.OtherModuleProvider(ctx, installedModule, ApexKeyPathInfoProvider); ok {
			installedApexKeys = append(installedApexKeys, info.ApexKeyPath)
		}
	}
	installedApexKeys = android.SortedUniquePaths(installedApexKeys) // Sort by keypath to match make
	builder.Command().Text("cat").Inputs(installedApexKeys).Textf(" >> %s/META/apexkeys.txt", targetFilesDir.String())
	// apkcerts.txt
	builder.Command().Textf("cp").Input(a.apkCertsInfo).Textf(" %s/META/", targetFilesDir.String())

	// Copy fastboot-info.txt
	if proptools.String(a.deviceProps.FastbootInfo) != "" {
		a.fastbootInfoFile = android.PathForModuleSrc(ctx, proptools.String(a.deviceProps.FastbootInfo))
	} else {
		// Autogenerate fastboot-info.txt if there is no source fastboot-info.txt
		a.fastbootInfoFile = a.createFastbootInfo(ctx)
	}
	builder.Command().Textf("cp").Input(a.fastbootInfoFile).Textf(" %s/META/fastboot-info.txt", targetFilesDir.String())

	// kernel_configs.txt and kernel_version.txt
	if a.kernelConfig != nil {
		builder.Command().Textf("cp").Input(a.kernelConfig).Textf(" %s/META/", targetFilesDir.String())
	}
	if a.kernelVersion != nil {
		builder.Command().Textf("cp").Input(a.kernelVersion).Textf(" %s/META/", targetFilesDir.String())
	}
	// misc_info.txt
	if a.miscInfo != nil {
		builder.Command().Textf("cp").Input(a.miscInfo).Textf(" %s/META/", targetFilesDir.String())
	}

	// Pack dynamic_partitions_info.txt to target-file.
	superPartitionName := a.partitionProps.Super_partition_name
	if superPartitionName == nil {
		superPartitionName = a.deviceProps.InfoPartitionProps.Super_partition_name
	}
	if superPartitionName != nil {
		superPartition := ctx.GetDirectDepProxyWithTag(*superPartitionName, superPartitionDepTag)
		if info, ok := android.OtherModuleProvider(ctx, superPartition, SuperImageProvider); ok {
			// dynamic_partitions_info.txt
			// TODO (b/390192334): Add `building_super_empty_partition=true`
			builder.Command().Text("cp").Input(info.DynamicPartitionsInfo).Textf(" %s/META/", targetFilesDir.String())
		} else {
			ctx.ModuleErrorf("Super partition %s does set SuperImageProvider\n", superPartition.Name())
		}
	}

	// apex_info.pb, care_map.pb, vbmeta_digest.txt, this should be the last part for generating target files due to the process of creating target file will run the release tool to create images base on the file system and configurations under META folder.
	a.addImgToTargetFiles(ctx, builder, targetFilesDir.String())
}

var (
	// https://cs.android.com/android/_/android/platform/build/+/30f05352c3e6f4333c77d4af66c253572d3ea6c9:core/Makefile;l=2111-2120;drc=519f75666431ee2926e0ec8991c682b28a4c9521;bpv=1;bpt=0
	defaultTargetRecoveryFstypeMountOptions = "ext4=max_batch_time=0,commit=1,data=ordered,barrier=1,errors=panic,nodelalloc"
)

// https://cs.android.com/android/_/android/platform/build/+/80b9546f8f69e78b8fe1870e0e745d70fc18dfcd:core/Makefile;l=5831-5893;drc=077490384423dff9eac954da5c001c6f0be3fa6e;bpv=0;bpt=0
func (a *androidDevice) createFastbootInfo(ctx android.ModuleContext) android.Path {
	fastbootInfo := android.PathForModuleOut(ctx, "fastboot-info.txt")
	var fastbootInfoString strings.Builder
	fastbootInfoString.WriteString(fmt.Sprintf("# fastboot-info for %s\n", ctx.Config().DeviceProduct()))
	fastbootInfoString.WriteString("version 1\n")
	if a.partitionProps.Boot_partition_name != nil {
		fastbootInfoString.WriteString("flash boot\n")
	}
	if a.partitionProps.Init_boot_partition_name != nil {
		fastbootInfoString.WriteString("flash init_boot\n")
	}
	if a.deviceProps.Dtbo_image != nil {
		fastbootInfoString.WriteString("flash dtbo\n")
	}
	if a.partitionProps.Vendor_kernel_boot_partition_name != nil {
		fastbootInfoString.WriteString("flash vendor_kernel_boot\n")
	}
	if a.deviceProps.Pvmfw.Image != nil {
		fastbootInfoString.WriteString("flash pvmfw\n")
	}
	if a.partitionProps.Vendor_boot_partition_name != nil {
		fastbootInfoString.WriteString("flash vendor_boot\n")
	}
	// vbmeta
	if len(a.partitionProps.Vbmeta_partitions) > 0 {
		fastbootInfoString.WriteString("flash --apply-vbmeta vbmeta\n")
	}
	var allChainedVbmetaPartitionTypes []string
	for _, vbmetaPartitionName := range a.partitionProps.Vbmeta_partitions {
		img := ctx.GetDirectDepProxyWithTag(vbmetaPartitionName, filesystemDepTag)
		if provider, ok := android.OtherModuleProvider(ctx, img, vbmetaPartitionProvider); ok {
			if provider.FilesystemPartitionType != "" { // the top-level vbmeta.img
				allChainedVbmetaPartitionTypes = append(allChainedVbmetaPartitionTypes, provider.FilesystemPartitionType)
			}
		} else {
			ctx.ModuleErrorf("vbmeta dep %s does not set vbmetaPartitionProvider\n", vbmetaPartitionName)
		}
	}
	for _, chainedVbmetaPartitionType := range []string{"system", "vendor"} {
		if android.InList(chainedVbmetaPartitionType, allChainedVbmetaPartitionTypes) {
			fastbootInfoString.WriteString(fmt.Sprintf("flash vbmeta_%s\n", chainedVbmetaPartitionType))
		}
	}

	fastbootInfoString.WriteString("reboot fastboot\n")
	fastbootInfoString.WriteString("update-super\n")

	var partitionsInSuper map[string]FilesystemInfo
	if a.partitionProps.Super_partition_name != nil {
		superPartition := ctx.GetDirectDepProxyWithTag(*a.partitionProps.Super_partition_name, superPartitionDepTag)
		if info, ok := android.OtherModuleProvider(ctx, superPartition, SuperImageProvider); ok {
			partitionsInSuper = info.SubImageInfo
		} else {
			ctx.ModuleErrorf("Super partition %s does not set SuperImageProvider\n", superPartition.Name())
		}
	}
	for _, partition := range []string{
		"system",
		"system_dlkm",
		"system_ext",
		"product",
		"vendor",
		"vendor_dlkm",
	} {
		if _, exists := partitionsInSuper[partition]; exists {
			fastbootInfoString.WriteString(fmt.Sprintf("flash %s\n", partition))
		}
	}

	if _, exists := partitionsInSuper["system_other"]; exists {
		fastbootInfoString.WriteString("flash --slot-other system system_other.img\n")
	}

	fastbootInfoString.WriteString("if-wipe erase userdata\n")

	// TODO: handle products with cache (PRODUCT_BUILD_CACHE_IMAGE=true)
	// fastbootInfoString.WriteString(fmt.Sprintf("if-wipe erase cache\n"))

	// TODO: Remove this hardcoding
	fastbootInfoString.WriteString("if-wipe erase metadata\n")

	android.WriteFileRuleVerbatim(ctx, fastbootInfo, fastbootInfoString.String())
	return fastbootInfo
}

// A partial implementation of make's $PRODUCT_OUT/misc_info.txt
// https://cs.android.com/android/platform/superproject/main/+/main:build/make/core/Makefile;l=5894?q=misc_info.txt%20f:build%2Fmake%2Fcore%2FMakefile&ss=android%2Fplatform%2Fsuperproject%2Fmain
// This file is subsequently used by add_img_to_target_files to create additioanl metadata files like apex_info.pb
// TODO (b/399788119): Complete the migration of misc_info.txt
func (a *androidDevice) addMiscInfo(ctx android.ModuleContext) android.Path {
	buildType := func() string {
		if ctx.Config().Debuggable() {
			return "userdebug"
		} else if ctx.Config().Eng() {
			return "eng"
		} else {
			return "user"
		}
	}
	defaultAppCertificate := func() string {
		pem, _ := ctx.Config().DefaultAppCertificate(ctx)
		return strings.TrimSuffix(pem.String(), ".x509.pem")
	}

	builder := android.NewRuleBuilder(pctx, ctx)
	miscInfo := android.PathForModuleOut(ctx, "misc_info.txt")
	builder.Command().
		Textf("rm -f %s", miscInfo).
		Textf("&& echo recovery_api_version=%s >> %s", ctx.Config().VendorConfig("recovery").String("recovery_api_version"), miscInfo).
		Textf("&& echo fstab_version=%s >> %s", ctx.Config().VendorConfig("recovery").String("recovery_fstab_version"), miscInfo).
		Textf("&& echo build_type=%s >> %s", buildType(), miscInfo).
		Textf("&& echo default_system_dev_certificate=%s >> %s", defaultAppCertificate(), miscInfo).
		Textf("&& echo root_dir=%s >> %s", android.PathForModuleInPartitionInstall(ctx, "root"), miscInfo).
		ImplicitOutput(miscInfo)
	if len(ctx.Config().ExtraOtaRecoveryKeys()) > 0 {
		builder.Command().Textf(`echo "extra_recovery_keys=%s" >> %s`, strings.Join(ctx.Config().ExtraOtaRecoveryKeys(), ""), miscInfo)
	} else {
		if a.partitionProps.Boot_partition_name != nil {
			builder.Command().
				Textf("echo mkbootimg_args='--header_version %s' >> %s", a.getBootimgHeaderVersion(ctx, a.partitionProps.Boot_partition_name), miscInfo).
				// TODO: Use boot's header version for recovery for now since cuttlefish does not set `BOARD_RECOVERY_MKBOOTIMG_ARGS`
				Textf(" && echo recovery_mkbootimg_args='--header_version %s' >> %s", a.getBootimgHeaderVersion(ctx, a.partitionProps.Boot_partition_name), miscInfo)
		} else if a.partitionProps.Vendor_boot_partition_name != nil {
			builder.Command().
				Textf("echo mkbootimg_args='--header_version %s' >> %s", a.getBootimgHeaderVersion(ctx, a.partitionProps.Vendor_boot_partition_name), miscInfo)
		}

		if a.partitionProps.Init_boot_partition_name != nil {
			builder.Command().
				Textf("echo mkbootimg_init_args='--header_version' %s >> %s", a.getBootimgHeaderVersion(ctx, a.partitionProps.Init_boot_partition_name), miscInfo)
		}
		builder.Command().
			Textf("echo mkbootimg_version_args='--os_version %s --os_patch_level %s' >> %s", ctx.Config().PlatformVersionLastStable(), ctx.Config().PlatformSecurityPatch(), miscInfo).
			Textf(" && echo multistage_support=1 >> %s", miscInfo).
			Textf(" && echo blockimgdiff_versions=3,4 >> %s", miscInfo)
	}
	fsInfos := a.getFsInfos(ctx)
	if _, ok := fsInfos["vendor"]; ok {
		builder.Command().Textf("echo board_uses_vendorimage=true >> %s", miscInfo)
	}
	if fsInfos["system"].ErofsCompressHints != nil {
		builder.Command().Textf("echo erofs_default_compress_hints=%s >> %s", fsInfos["system"].ErofsCompressHints, miscInfo)
	} else {
		// Use other partitions' ErofsCompressHints if system partition's not exist.
		for _, partition := range android.SortedKeys(fsInfos) {
			if fsInfos[partition].ErofsCompressHints != nil {
				builder.Command().Textf("echo erofs_default_compress_hints=%s >> %s", fsInfos[partition].ErofsCompressHints, miscInfo)
				break
			}
		}
	}
	if proptools.String(a.deviceProps.Releasetools_extension) != "" {
		releaseTools := android.PathForModuleSrc(ctx, proptools.String(a.deviceProps.Releasetools_extension))
		builder.Command().Textf("echo tool_extensions=%s >> %s", filepath.Dir(releaseTools.String()), miscInfo)
	}
	// ramdisk uses `compressed_cpio` fs_type
	// https://cs.android.com/android/_/android/platform/build/+/30f05352c3e6f4333c77d4af66c253572d3ea6c9:core/Makefile;l=5923-5925;drc=519f75666431ee2926e0ec8991c682b28a4c9521;bpv=1;bpt=0
	if _, ok := fsInfos["ramdisk"]; ok {
		// http://b/428047677#comment3
		// TODO: Consider using `BOARD_RAMDISK_USE_LZ4` instead.
		builder.Command().Textf("echo lz4_ramdisks=true >> %s", miscInfo)
	} else if _, ok := fsInfos["vendor_ramdisk"]; ok {
		// http://b/428047677#comment3
		// TODO: Consider using `BOARD_RAMDISK_USE_LZ4` instead.
		builder.Command().Textf("echo lz4_ramdisks=true >> %s", miscInfo)
	}
	// recovery_mount_options
	// TODO: Add support for TARGET_RECOVERY_FSTYPE_MOUNT_OPTIONS which can be used to override the default
	builder.Command().Textf("echo recovery_mount_options=%s >> %s", defaultTargetRecoveryFstypeMountOptions, miscInfo)

	// vintf information
	if proptools.Bool(ctx.Config().ProductVariables().Enforce_vintf_manifest) {
		builder.Command().Textf("echo vintf_enforce=true >> %s", miscInfo)
	}
	if len(ctx.Config().DeviceManifestFiles()) > 0 {
		builder.Command().Textf("echo vintf_include_empty_vendor_sku=true >> %s", miscInfo)
	}

	if a.partitionProps.Recovery_partition_name == nil {
		builder.Command().Textf("echo no_recovery=true >> %s", miscInfo)
	}
	for _, partition := range android.SortedKeys(fsInfos) {
		if fsInfos[partition].PropFileForMiscInfo != nil {
			builder.Command().Text("cat").Input(fsInfos[partition].PropFileForMiscInfo).Textf(" >> %s", miscInfo)
		}
	}
	if len(a.partitionProps.Vbmeta_partitions) > 0 {
		builder.Command().
			Textf("echo avb_enable=true >> %s", miscInfo).
			Textf("&& echo avb_building_vbmeta_image=true >> %s", miscInfo).
			Textf("&& echo avb_avbtool=avbtool >> %s", miscInfo)

		var allChainedVbmetaPartitionTypes []string
		for _, vbmetaPartitionName := range a.partitionProps.Vbmeta_partitions {
			img := ctx.GetDirectDepProxyWithTag(vbmetaPartitionName, filesystemDepTag)
			if provider, ok := android.OtherModuleProvider(ctx, img, vbmetaPartitionProvider); ok {
				builder.Command().Text("cat").Input(provider.PropFileForMiscInfo).Textf(" >> %s", miscInfo)
				if provider.FilesystemPartitionType != "" { // the top-level vbmeta.img
					allChainedVbmetaPartitionTypes = append(allChainedVbmetaPartitionTypes, provider.FilesystemPartitionType)
				}
			} else {
				ctx.ModuleErrorf("vbmeta dep %s does not set vbmetaPartitionProvider\n", vbmetaPartitionName)
			}
		}
		// Determine the custom vbmeta partitions by removing system and vendor
		customVbmetaPartitionTypes := android.RemoveListFromList(allChainedVbmetaPartitionTypes, []string{"system", "vendor"})
		builder.Command().Textf("echo avb_custom_vbmeta_images_partition_list=%s >> %s",
			strings.Join(android.SortedUniqueStrings(customVbmetaPartitionTypes), " "),
			miscInfo,
		)

	}
	if a.partitionProps.Boot_partition_name != nil {
		builder.Command().Textf("echo boot_images=boot.img >> %s", miscInfo)
	}

	if a.partitionProps.Super_partition_name != nil {
		superPartition := ctx.GetDirectDepProxyWithTag(*a.partitionProps.Super_partition_name, superPartitionDepTag)
		if info, ok := android.OtherModuleProvider(ctx, superPartition, SuperImageProvider); ok {
			// cat dynamic_partition_info.txt
			builder.Command().Text("cat").Input(info.DynamicPartitionsInfo).Textf(" >> %s", miscInfo)
			if info.AbUpdate {
				builder.Command().Textf("echo ab_update=true >> %s", miscInfo)
			}

		} else {
			ctx.ModuleErrorf("Super partition %s does set SuperImageProvider\n", superPartition.Name())
		}
	}
	bootImgNames := []*string{
		a.partitionProps.Boot_partition_name,
		a.partitionProps.Init_boot_partition_name,
		a.partitionProps.Vendor_boot_partition_name,
		a.partitionProps.Vendor_kernel_boot_partition_name,
	}
	for _, bootImgName := range bootImgNames {
		if bootImgName == nil {
			continue
		}

		bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(bootImgName), filesystemDepTag)
		bootImgInfo, _ := android.OtherModuleProvider(ctx, bootImg, BootimgInfoProvider)
		// cat avb_ metadata of the boot images
		builder.Command().Text("cat").Input(bootImgInfo.PropFileForMiscInfo).Textf(" >> %s", miscInfo)
	}

	if proptools.String(a.deviceProps.Flash_block_size) != "" {
		builder.Command().Textf("echo blocksize=%s >> %s", proptools.String(a.deviceProps.Flash_block_size), miscInfo)
	}
	if proptools.Bool(a.deviceProps.Bootloader_in_update_package) {
		builder.Command().Textf("echo bootloader_in_update_package=true >> %s", miscInfo)
	}
	if len(a.deviceProps.Partial_ota_update_partitions) > 0 {
		builder.Command().Textf("echo partial_ota_update_partitions_list=%s >> %s", strings.Join(a.deviceProps.Partial_ota_update_partitions, " "), miscInfo)
	}
	if a.deviceProps.Dtbo_image != nil {
		dtbo := ctx.GetDirectDepProxyWithTag(*a.deviceProps.Dtbo_image, dtboDepTag)
		if info, ok := android.OtherModuleProvider(ctx, dtbo, DtboImgInfoProvider); ok {
			builder.Command().Text("cat").Input(info.PropFileForMiscInfo).Textf(" >> %s", miscInfo)
		} else {
			ctx.ModuleErrorf("Could not write dtbo properties in misc_info.txt")
		}
	}
	if a.deviceProps.Pvmfw.Image != nil {
		builder.Command().Textf("echo has_pvmfw=true >> %s", miscInfo)
		if a.deviceProps.Pvmfw.Partition_size != nil {
			builder.Command().Textf("echo pvmfw_size=%d >> %s", *a.deviceProps.Pvmfw.Partition_size, miscInfo)
		} else {
			builder.Command().Textf("echo pvmfw_size= >> %s", miscInfo)
		}
		fingerprintFile := ctx.Config().BuildFingerprintFile(ctx)
		builder.Command().Textf("echo avb_pvmfw_add_hash_footer_args=--prop com.android.build.pvmfw.fingerprint:$(cat %s) >> %s", fingerprintFile.String(), miscInfo).Implicit(fingerprintFile)
	}

	// Sort and dedup
	builder.Command().Textf("sort -u %s -o %s", miscInfo, miscInfo)

	builder.Build("misc_info", "Building misc_info")

	return miscInfo
}

func (a *androidDevice) getBootimgHeaderVersion(ctx android.ModuleContext, bootImgName *string) string {
	bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(bootImgName), filesystemDepTag)
	bootImgInfo, _ := android.OtherModuleProvider(ctx, bootImg, BootimgInfoProvider)
	return bootImgInfo.HeaderVersion
}

// addImgToTargetFiles invokes `add_img_to_target_files` and creates the following files in META/
// - apex_info.pb
// - care_map.pb
// - vbmeta_digest.txt
func (a *androidDevice) addImgToTargetFiles(ctx android.ModuleContext, builder *android.RuleBuilder, targetFilesDir string) {
	mkbootimg := ctx.Config().HostToolPath(ctx, "mkbootimg")
	lpmake := ctx.Config().HostToolPath(ctx, "lpmake")
	builder.Command().
		Textf("PATH=%s:$PATH", ctx.Config().HostToolDir()).
		Textf("MKBOOTIMG=%s", mkbootimg).
		Implicit(mkbootimg).
		Implicit(lpmake).
		BuiltTool("add_img_to_target_files").
		Flag("-a -v -p").
		Flag(ctx.Config().HostToolDir()).
		Text(targetFilesDir)
}

func (a *androidDevice) buildUpdatePackage(ctx android.ModuleContext) {
	var exclusions []string
	fsInfos := a.getFsInfos(ctx)
	// Exclude the partitions that are not supported by flashall
	for _, partition := range android.SortedKeys(fsInfos) {
		if fsInfos[partition].NoFlashall {
			exclusions = append(exclusions, fmt.Sprintf("IMAGES/%s.img", partition))
			exclusions = append(exclusions, fmt.Sprintf("IMAGES/%s.map", partition))
		}
	}

	updatePackage := android.PathForModuleOut(ctx, "img.zip")
	rule := android.NewRuleBuilder(pctx, ctx)

	buildSuperImage := ctx.Config().HostToolPath(ctx, "build_super_image")
	zip2zip := ctx.Config().HostToolPath(ctx, "zip2zip")

	rule.Command().
		BuiltTool("img_from_target_files").
		Text("--additional IMAGES/VerifiedBootParams.textproto:VerifiedBootParams.textproto").
		FlagForEachArg("--exclude ", exclusions).
		FlagWithArg("--build_super_image ", buildSuperImage.String()).
		Implicit(buildSuperImage).
		Implicit(zip2zip).
		Input(a.targetFilesZip).
		Output(updatePackage)

	rule.Build("updatepackage", "Building updatepackage")

	a.updatePackage = updatePackage
}

func (a *androidDevice) buildWithLicenseZip(ctx android.ModuleContext) {
	name := ""
	if ctx.Config().HasDeviceProduct() {
		if ctx.Config().BuildType() == "debug" {
			name = ctx.Config().DeviceProduct() + "_debug-"
		} else {
			name = ctx.Config().DeviceProduct() + "-"
		}
	}
	a.withLicenseDistName = name + "flashable-FILE_NAME_TAG_PLACEHOLDER-with-license.sh"
	name += "flashable-with-license"

	withLicense := android.PathForModuleOut(ctx, "with-license", name+".sh")
	a.withLicenseFile = withLicense
	if proptools.String(a.deviceProps.Vendor_blobs_license) == "" {
		android.ErrorRule(ctx, withLicense, "with-license requires VENDOR_BLOBS_LICENSE to be set.")
		return
	}

	intermediateZip := android.PathForModuleOut(ctx, "with-license", name+".zip")
	intermediateBuilder := android.NewRuleBuilder(pctx, ctx)
	intermediateBuilder.Command().
		BuiltTool("zip2zip").
		FlagWithInput("-i ", a.targetFilesZip).
		FlagWithOutput("-o ", intermediateZip).
		Text("RADIO/bootloader.img:bootloader.img").
		Text("RADIO/radio.img:radio.img").
		Text("IMAGES/*.img:.").
		Text("OTA/android-info.txt:android-info.txt")
	intermediateBuilder.Build("with_license_intermediate_zip", "with-license intermediate zip")

	withLicenseBuilder := android.NewRuleBuilder(pctx, ctx)
	withLicenseBuilder.Command().
		BuiltTool("generate-self-extracting-archive").
		Output(withLicense).
		Input(intermediateZip).
		Text(name).
		Input(android.PathForModuleSrc(ctx, *a.deviceProps.Vendor_blobs_license))
	withLicenseBuilder.Build("with_license", "build with-license")
}

type ApexKeyPathInfo struct {
	ApexKeyPath android.Path
}

var ApexKeyPathInfoProvider = blueprint.NewProvider[ApexKeyPathInfo]()

func (a *androidDevice) generateFilesystemConfigForTargetFiles(ctx android.ModuleContext, builder *android.RuleBuilder, stagingDirTimestamp android.Path, targetFilesDir, stagingDir, filename string) {
	fsConfigOut := android.PathForModuleOut(ctx, filename)
	ctx.Build(pctx, android.BuildParams{
		Rule:     fsConfigRule,
		Implicit: stagingDirTimestamp,
		Output:   fsConfigOut,
		Args: map[string]string{
			"rootDir": stagingDir,
			"prefix":  "",
		},
	})
	builder.Command().Textf("cp").Input(fsConfigOut).Textf(" %s/META/", targetFilesDir)
}

// Filenames for the partition specific fs_config files.
// Hardcode the ramdisk files to their boot image prefix
func (a *androidDevice) filesystemConfigNameForTargetFiles(partition string) string {
	name := partition + "_filesystem_config.txt"
	if partition == "system" {
		name = "filesystem_config.txt"
	} else if partition == "ramdisk" {
		name = "init_boot_filesystem_config.txt"
	}
	return name
}

func (a *androidDevice) getFilesystemInfo(ctx android.ModuleContext, depName string) FilesystemInfo {
	fsMod := ctx.GetDirectDepProxyWithTag(depName, filesystemDepTag)
	fsInfo, ok := android.OtherModuleProvider(ctx, fsMod, FilesystemProvider)
	if !ok {
		ctx.ModuleErrorf("Expected dependency %s to be a filesystem", depName)
	}
	return fsInfo
}

func (a *androidDevice) setVbmetaPhonyTargets(ctx android.ModuleContext) {
	if !proptools.Bool(a.deviceProps.Main_device) {
		return
	}

	if !ctx.Config().KatiEnabled() {
		for _, vbmetaPartitionName := range a.partitionProps.Vbmeta_partitions {
			img := ctx.GetDirectDepProxyWithTag(vbmetaPartitionName, filesystemDepTag)
			if provider, ok := android.OtherModuleProvider(ctx, img, vbmetaPartitionProvider); ok {
				// make generates `vbmetasystemimage` phony target instead of `vbmeta_systemimage` phony target.
				partitionName := strings.ReplaceAll(provider.Name, "_", "")
				ctx.Phony(fmt.Sprintf("%simage", partitionName), provider.Output)
			}
		}
	}
}

func (a *androidDevice) getKernel(ctx android.ModuleContext) android.Path {
	if a.partitionProps.Boot_partition_name != nil {
		bootImg := ctx.GetDirectDepProxyWithTag(proptools.String(a.partitionProps.Boot_partition_name), filesystemDepTag)
		bootImgInfo, _ := android.OtherModuleProvider(ctx, bootImg, BootimgInfoProvider)
		return bootImgInfo.Kernel
	}
	return nil
}

// Gets the kernel version and configs from the actual kernel file itself. Roughly equivalent to
// this make code: https://cs.android.com/android/platform/superproject/main/+/main:build/make/core/Makefile;l=5443;drc=c0b66fc59de069e06ce0ffd703d4d21613be30c6
// However, it is a simplified version of that make code. Differences include:
//   - Not handling BOARD_KERNEL_CONFIG_FILE because BOARD_KERNEL_CONFIG_FILE was never used.
//   - Not unpacking the bootimage, as we should be able to just always export the kernel directly
//     in the BootimgInfo. We don't currently support prebuilt boot images, but even if we add that
//     in the future, it can be done in a prebuilt_bootimage module type that still exports the same
//     BootimgInfo.
//   - We don't print a warning and output '<unknown-kernel>' to kernel_version_for_uffd_gc.txt
//     because we expect the kernel to always be present. If it's not, we will get an error that
//     kernel_version_for_uffd_gc.txt doesn't exist. This may require later tweaking to the
//     dexpreopt rules so that they don't attempt to access that file in builds that don't have
//     a kernel.
func (a *androidDevice) extractKernelVersionAndConfigs(ctx android.ModuleContext) (android.Path, android.Path) {
	kernel := a.getKernel(ctx)
	// If there's no kernel, don't create kernel version / kernel config files. Reverse dependencies
	// on those files have to account for this, for example by disabling dexpreopt in unbundled
	// builds.
	if kernel == nil {
		return nil, nil
	}

	lz4tool := ctx.Config().HostToolPath(ctx, "lz4")

	extractedVersionFile := android.PathForModuleOut(ctx, "kernel_version.txt")
	extractedConfigsFile := android.PathForModuleOut(ctx, "kernel_configs.txt")
	builder := android.NewRuleBuilder(pctx, ctx)
	builder.Command().BuiltTool("extract_kernel").
		Flag("--tools lz4:"+lz4tool.String()).Implicit(lz4tool).
		FlagWithInput("--input ", kernel).
		FlagWithOutput("--output-release ", extractedVersionFile).
		FlagWithOutput("--output-configs ", extractedConfigsFile)

	if specifiedVersion := proptools.String(a.deviceProps.Kernel_version); specifiedVersion != "" {
		specifiedVersionFile := android.PathForModuleOut(ctx, "specified_kernel_version.txt")
		android.WriteFileRuleVerbatim(ctx, specifiedVersionFile, specifiedVersion)
		builder.Command().Text("diff -q").
			Input(specifiedVersionFile).
			Input(extractedVersionFile).
			Textf(`|| (echo "Specified kernel version '$(cat %s)' does not match actual kernel version '$(cat %s)'"; exit 1)`, specifiedVersionFile, extractedVersionFile)
	}

	builder.Build("extract_kernel_info", "Extract kernel version and configs")

	if proptools.Bool(a.deviceProps.Main_device) && !ctx.Config().KatiEnabled() {
		if ctx.Config().EnableUffdGc() == "default" {
			kernelVersionFile := android.PathForOutput(ctx, "dexpreopt/kernel_version_for_uffd_gc.txt")
			ctx.Build(pctx, android.BuildParams{
				Rule:   android.CpIfChanged,
				Input:  extractedVersionFile,
				Output: kernelVersionFile,
			})
		}

		ctx.DistForGoal("droid_targets", extractedVersionFile)
	}

	return extractedVersionFile, extractedConfigsFile
}

func (a *androidDevice) buildApkCertsInfo(ctx android.ModuleContext) android.Path {
	apkCerts := []string{}
	fsInfos := a.getFsInfos(ctx)
	if fsInfos["system"].HasFsverity {
		defaultPem, defaultKey := ctx.Config().DefaultAppCertificate(ctx)
		apkCerts = append(apkCerts, java.FormatApkCertsLine(java.Certificate{Pem: defaultPem, Key: defaultKey}, "BuildManifest.apk", "system"))
		if info, ok := fsInfos["system_ext"]; ok && info.HasFsverity {
			apkCerts = append(apkCerts, java.FormatApkCertsLine(java.Certificate{Pem: defaultPem, Key: defaultKey}, "BuildManifestSystemExt.apk", "system_ext"))
		}
	}

	apkCertsForBuildManifest := android.PathForModuleOut(ctx, "apkcerts_for_buildmanifest.txt")
	android.WriteFileRuleVerbatim(ctx, apkCertsForBuildManifest, strings.Join(apkCerts, "\n")+"\n")
	apkCertsInfo := android.PathForModuleOut(ctx, "apkcerts.txt")
	ctx.Build(pctx, android.BuildParams{
		Rule:        android.CatAndSort,
		Description: "combine apkcerts.txt",
		Output:      apkCertsInfo,
		Inputs:      android.Paths{java.ApkCertsFile(ctx), apkCertsForBuildManifest},
	})
	return apkCertsInfo
}

func findAllPreinstalledApps(partitions []string, fsInfos map[string]FilesystemInfo) android.Paths {
	var ret android.Paths
	for _, partition := range partitions {
		info, ok := fsInfos[partition]
		if !ok {
			continue
		}
		// use MustCompile, because if `partition` is invalid, then we already did something wrong
		apkPattern := regexp.MustCompile(partition + `/(app|priv-app)/[^/]+/[^/]+\.apk$`)
		for _, path := range info.FullInstallPaths {
			if !path.IsDir && path.SymlinkTarget == "" &&
				apkPattern.FindString(path.FullInstallPath.String()) != "" {
				ret = append(ret, path.SourcePath)
			}
		}
	}
	return android.SortedUniquePaths(ret)
}

func findInstalledFile(rel string, info FilesystemInfo) android.Path {
	for _, path := range info.FullInstallPaths {
		if !path.IsDir && path.SymlinkTarget == "" &&
			strings.HasSuffix(path.FullInstallPath.String(), rel) {
			return path.SourcePath
		}
	}
	return nil
}

func findFilesInPartitions(paths map[string]string, fsInfos map[string]FilesystemInfo) android.Paths {
	var ret android.Paths
	for partition, rel := range paths {
		info, ok := fsInfos[partition]
		if !ok {
			continue
		}

		if path := findInstalledFile(rel, info); path != nil {
			ret = append(ret, path)
		}
	}
	return android.SortedUniquePaths(ret)
}

func (a *androidDevice) buildTrebleLabelingTest(ctx android.ModuleContext) android.Path {
	platformPartitions := []string{
		"system",
		"system_ext",
		"product",
	}

	vendorPartitions := []string{
		"vendor",
		"odm",
	}

	fsInfos := a.getFsInfos(ctx)

	platformApps := findAllPreinstalledApps(platformPartitions, fsInfos)
	vendorApps := findAllPreinstalledApps(vendorPartitions, fsInfos)

	platformSeappContextsPaths := map[string]string{
		"system":     "system/etc/selinux/plat_seapp_contexts",
		"system_ext": "system_ext/etc/selinux/system_ext_seapp_contexts",
		"product":    "product/etc/selinux/product_seapp_contexts",
	}
	platformSeappContexts := findFilesInPartitions(platformSeappContextsPaths, fsInfos)

	vendorSeappContextsPaths := map[string]string{
		"vendor": "vendor/etc/selinux/vendor_seapp_contexts",
		"odm":    "odm/etc/selinux/odm_seapp_contexts",
	}
	vendorSeappContexts := findFilesInPartitions(vendorSeappContextsPaths, fsInfos)

	vendorFileContextsPaths := map[string]string{
		"vendor": "vendor/etc/selinux/vendor_file_contexts",
		"odm":    "odm/etc/selinux/odm_file_contexts",
	}
	vendorFileContexts := findFilesInPartitions(vendorFileContextsPaths, fsInfos)

	precompiledSepolicyPaths := map[string]string{
		"odm":    "odm/etc/selinux/precompiled_sepolicy",
		"vendor": "vendor/etc/selinux/precompiled_sepolicy",
	}
	precompiledSepolicies := findFilesInPartitions(precompiledSepolicyPaths, fsInfos)

	testTimestamp := android.PathForModuleOut(ctx, "treble_labeling_test.timestamp")

	platformAppsList := android.PathForModuleOut(ctx, "platform_apps.txt")
	android.WriteFileRule(ctx, platformAppsList, strings.Join(platformApps.Strings(), "\n"))
	vendorAppsList := android.PathForModuleOut(ctx, "vendor_apps.txt")
	android.WriteFileRule(ctx, vendorAppsList, strings.Join(vendorApps.Strings(), "\n"))

	// Skip treble labeling tests if required artifacts are missing
	// This can happen when building with prebuilt images, for example.
	shouldSkipTest := len(platformSeappContexts) == 0 ||
		len(vendorSeappContexts) == 0 ||
		len(vendorFileContexts) == 0 ||
		len(precompiledSepolicies) == 0 ||
		proptools.String(a.deviceProps.Precompiled_sepolicy_without_vendor) == ""

	rule := android.NewRuleBuilder(pctx, ctx)

	if len(precompiledSepolicies) > 1 {
		errorMessage := fmt.Sprintf("number of precompiled_sepolicy must not be greater than one but was %q", precompiledSepolicies.Strings())
		rule.Command().
			Text("echo").
			Text(proptools.ShellEscape(errorMessage)).
			Text(" && exit 1").
			ImplicitOutput(testTimestamp)
	} else if shouldSkipTest {
		errorMessage := "cannot find necessary artifacts. skipping tests.\\n"
		errorMessage += fmt.Sprintf("platformSeappContexts: %q\\n", platformSeappContexts.Strings())
		errorMessage += fmt.Sprintf("vendorSeappContexts: %q\\n", vendorSeappContexts.Strings())
		errorMessage += fmt.Sprintf("vendorFileContexts: %q\\n", vendorFileContexts.Strings())
		errorMessage += fmt.Sprintf("precompiledSepolicies: %q\\n", precompiledSepolicies.Strings())
		errorMessage += fmt.Sprintf("precompiled_sepolicy_without_vendor: %q\\n", proptools.String(a.deviceProps.Precompiled_sepolicy_without_vendor))

		rule.Command().
			Text("echo").
			Flag("-e").
			Text(proptools.ShellEscape(errorMessage)).
			FlagWithOutput("> ", testTimestamp)
	} else {
		precompiledSepolicyWithoutVendor := android.PathForModuleSrc(ctx, proptools.String(a.deviceProps.Precompiled_sepolicy_without_vendor))
		cmd := rule.Command().BuiltTool("treble_labeling_tests").
			FlagWithInput("--platform_apks ", platformAppsList).
			FlagWithInput("--vendor_apks ", vendorAppsList).
			FlagWithInput("--precompiled_sepolicy_without_vendor ", precompiledSepolicyWithoutVendor).
			FlagWithInput("--precompiled_sepolicy ", precompiledSepolicies[0]). // len(precompiledSepolicies) == 1
			FlagWithInputList("--platform_seapp_contexts ", platformSeappContexts, " ").
			FlagWithInputList("--vendor_seapp_contexts ", vendorSeappContexts, " ").
			FlagWithInputList("--vendor_file_contexts ", vendorFileContexts, " ").
			FlagWithInput("--aapt2_path ", ctx.Config().HostToolPath(ctx, "aapt2")).
			Implicits(platformApps).
			Implicits(vendorApps)

		trackingListFile := ctx.Config().SELinuxTrebleLabelingTrackingListFile(ctx)
		if trackingListFile != nil {
			cmd.FlagWithInput("--tracking_list_file ", trackingListFile)
		}

		if !ctx.Config().EnforceSELinuxTrebleLabeling() {
			cmd.Flag("--treat_as_warnings")
		}

		if ctx.Config().Debuggable() {
			cmd.Flag("--debuggable")
		}

		cmd.FlagWithOutput("> ", testTimestamp)
	}

	rule.Build("treble_labeling_test", "SELinux Treble Labeling Test")

	if !ctx.Config().KatiEnabled() && proptools.Bool(a.deviceProps.Main_device) {
		ctx.Phony("check-selinux-treble-labeling", testTimestamp)
	}

	return testTimestamp
}

func (a *androidDevice) checkVintf(ctx android.ModuleContext) {
	if !proptools.Bool(a.deviceProps.Main_device) {
		return
	}
	if ctx.Config().KatiEnabled() {
		// Make will generate the vintf checks.
		return
	}
	var checkVintfLogs android.Paths
	fsInfoMap := a.getFsInfos(ctx)
	for _, partition := range android.SortedKeys(fsInfoMap) {
		checkVintfLog := fsInfoMap[partition].checkVintfLog
		if checkVintfLog != nil {
			checkVintfLogs = append(checkVintfLogs, checkVintfLog)
		}
	}
	checkVintfLogs = append(checkVintfLogs, a.createMonolithicVintfCompatibleLog(ctx, fsInfoMap))

	rule := android.NewRuleBuilder(pctx, ctx)
	rule.SetPhonyOutput()
	cmd := rule.Command()
	for _, checkVintfLog := range checkVintfLogs {
		cmd.Textf(" echo %s; cat %s; echo; ", checkVintfLog, checkVintfLog).Implicit(checkVintfLog)
	}
	cmd.ImplicitOutput(android.PathForPhony(ctx, "check-vintf-all"))
	rule.Build("check-vintf-all", "check-vintf-all")
}

// Runs checkvintf --check-compat on the staging directories of the partitions per (odm_sku, vendor_sku)
func (a *androidDevice) createMonolithicVintfCompatibleLog(ctx android.ModuleContext, fsInfos map[string]FilesystemInfo) android.Path {
	addPartitionsToApexdCmd := func(cmd *android.RuleBuilderCommand) {
		for _, partition := range []string{"system", "vendor", "odm", "product", "system_ext"} {
			// Some devices might not have all partitions, check existence.
			if _, exists := fsInfos[partition]; exists {
				cmd.FlagWithArg(fmt.Sprintf(" --%s_path ", partition), fsInfos[partition].RebasedDir.String()).
					Implicit(fsInfos[partition].Output)
			}
		}
	}
	addPartitionsToCheckVintfCmd := func(cmd *android.RuleBuilderCommand) {
		for _, partition := range []string{"system", "vendor", "odm", "product", "system_ext"} {
			// Some devices might not have all partitions, check existence.
			if _, exists := fsInfos[partition]; exists {
				cmd.FlagWithArg("--dirmap ", fmt.Sprintf("/%s:%s", partition, fsInfos[partition].RebasedDir.String())).
					Implicit(fsInfos[partition].Output)
			}
		}
	}

	checkVintfLog := android.PathForModuleOut(ctx, "vintf", "check_vintf_compatible.log")
	extractedApexDir := android.PathForModuleOut(ctx, "vintf", "apex_extracted")

	builder := android.NewRuleBuilder(pctx, ctx)
	// Use apexd_host to extract the apexes of the partitions to an intermediate location.
	// This intermediate location will be subsequently used by checkvintf.
	cmd := builder.Command()
	cmd.Textf("rm -rf %s", checkVintfLog)
	cmd.Textf("rm -rf %s && mkdir -p %s && ", extractedApexDir.String(), extractedApexDir.String())
	cmd.BuiltTool("apexd_host")
	addPartitionsToApexdCmd(cmd)
	cmd.FlagWithArg(" --apex_path ", extractedApexDir.String())

	var additionalArgs string
	if a.kernelVersion != nil && a.kernelConfig != nil {
		additionalArgs += fmt.Sprintf(
			" --kernel %s:%s ",
			a.kernelVersion.String(),
			a.kernelConfig.String(),
		)
	}
	additionalArgs += fmt.Sprintf(
		" --property ro.product.first_api_level=%s ",
		ctx.DeviceConfig().ShippingApiLevel(),
	)

	// TODO: Handle devices that set PRODUCT_OTA_ENFORCE_VINTF_KERNEL_REQUIREMENTS to false.
	if a.kernelVersion != nil {
		builder.Command().Textf("echo -n -e PRODUCT_OTA_ENFORCE_VINTF_KERNEL_REQUIREMENTS=true >> %s", checkVintfLog)
	}
	builder.Command().Textf("echo -n -e 'Args: \\n  ' >> %s", checkVintfLog)
	builder.Command().Textf("echo -n -e '%s: \\n  ' >> %s", additionalArgs, checkVintfLog)

	for _, odmSku := range odmSkusForCheckVintf(ctx) {
		for _, vendorSku := range deviceSkusForCheckVintf(ctx) {
			cmd := builder.Command()
			cmd.Textf("echo -n -e 'For ODM SKU = %s, vendor SKU = %s \\n ' >> %s && ", odmSku, vendorSku, checkVintfLog).
				BuiltTool("checkvintf").
				Flag("--check-compat").
				Flag(additionalArgs)
			addPartitionsToCheckVintfCmd(cmd)
			cmd.FlagWithArg("--dirmap ", fmt.Sprintf("/apex:%s", extractedApexDir.String())).
				FlagWithArg("--property ", "ro.boot.product.hardware.sku="+odmSku).
				FlagWithArg("--property ", "ro.boot.product.vendor.sku="+vendorSku).
				FlagWithOutput(">> ", checkVintfLog).
				Flag("2>&1 ").
				Textf(" || ( cat %s && exit 1 ); ", checkVintfLog.String())
		}
	}

	builder.Build("check_vintf_compatible", "check_vintf_compatible")
	return checkVintfLog
}

func (a *androidDevice) runApexSepolicyTests(ctx android.ModuleContext, allInstalledModules []android.ModuleProxy) {
	var installedApexes []android.ModuleProxy
	for _, installedModule := range allInstalledModules {
		if _, isApex := android.OtherModuleProvider(ctx, installedModule, android.ApexBundleInfoProvider); isApex {
			installedApexes = append(installedApexes, installedModule)
		}
	}

	var outputFiles android.Paths
	for _, installedApex := range installedApexes {
		apexName := ctx.OtherModuleName(installedApex)
		outputFile := android.PathForModuleOut(ctx, "apex_sepolicy_tests", apexName, "pass.txt")
		inputApex := android.OutputFileForModule(ctx, installedApex, "")
		rule := android.NewRuleBuilder(pctx, ctx)
		rule.Command().
			BuiltTool("apex-ls").
			Flag("-Z").
			Input(inputApex).
			Text("|").
			BuiltTool("apex_sepolicy_tests").
			Flag("--all").
			FlagWithArg("-f ", "-")
		rule.Command().
			Text("touch").
			Output(outputFile)
		rule.Build("Run apex sepolicy test "+apexName, "run_apex_sepolicy_test_"+apexName)
		outputFiles = append(outputFiles, outputFile)
	}

	if !ctx.Config().KatiEnabled() && proptools.Bool(a.deviceProps.Main_device) {
		ctx.Phony("run_apex_sepolicy_tests", outputFiles...)
		ctx.Phony("droid_targets", android.PathForPhony(ctx, "run_apex_sepolicy_tests"))
	}
}

func (a *androidDevice) checkRadioVersion(ctx android.ModuleContext) android.WritablePath {
	checkRadioVersionTimestamp := android.PathForModuleOut(ctx, "check_radio_version.timestamp")
	rule := android.NewRuleBuilder(pctx, ctx)
	rule.Command().Text("touch").Output(checkRadioVersionTimestamp)

	cmd := rule.Command()
	cmd.BuiltTool("check_radio_versions")
	cmd.FlagWithInput("--board_info_txt ", a.boardInfoTxt)

	cmd.Flag("--board_info_check")
	bootloader := ctx.GetDirectDepProxyWithTag(*a.deviceProps.Bootloader, bootloaderDepTag)
	if bootloaderInfo, ok := android.OtherModuleProvider(ctx, bootloader, bootloaderInfoProvider); ok {
		bootloaderImg := bootloaderInfo.bootloaderImg
		cmd.Textf("version-bootloader:%s", bootloaderImg).
			Implicit(bootloaderImg)
	} else {
		ctx.PropertyErrorf("Bootloader", "Must be the prebuilt_bootloader module type")
	}

	if a.deviceProps.Radio_partition_name != nil {
		radio := ctx.GetDirectDepProxyWithTag(*a.deviceProps.Radio_partition_name, radioDepTag)
		if radioInfo, ok := android.OtherModuleProvider(ctx, radio, radioInfoProvider); ok {
			radioImg := radioInfo.image
			if radioImg != nil {
				cmd.Textf("version-baseband:%s", radioImg).
					Implicit(radioImg)
			}
		} else {
			ctx.PropertyErrorf("Radio_partition_name", "Must be the prebuilt_radio_image module type")
		}
	}

	rule.Build("check_radio_version", "Check radio version")

	return checkRadioVersionTimestamp
}
